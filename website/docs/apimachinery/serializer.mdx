---
sidebar_position: 5
---
import GithubSVG from '@site/static/img/github-mark.svg';
import KubernetesSVG from '@site/static/img/kubernetes-mark.svg';
import SerializerBasicSVG from '@site/static/img/serializer-basic.svg';
import SerializerAdvanceSVG from '@site/static/img/serializer-advance.svg';


# åºåˆ—åŒ–å™¨ä¸åºåˆ—åŒ–å™¨å·¥å‚

æˆ‘ä»¬åœ¨[ä»Kubernetes APIè°ˆèµ·](./kubernetes-api)å°èŠ‚ä¸­ï¼Œæˆ‘ä»¬å·²ç»çŸ¥é“`kube-apiserver`æ˜¯ç³»ç»Ÿç®¡ç†èµ„æºçš„å”¯ä¸€å¯¹å¤–äº¤äº’æ¥å£ã€‚
ä¸ç®¡æ˜¯å®¢æˆ·ç«¯ï¼Œè¿˜æ˜¯Kubernetesç³»ç»Ÿå†…éƒ¨å…¶ä»–ç»„ä»¶ï¼ˆ`kubelet`ç­‰ï¼‰å®ƒä»¬éƒ½åªèƒ½é€šè¿‡`kube-apiserver`ä½¿ç”¨HTTPå¯¹èµ„æºè¿›è¡Œç®¡ç†ã€‚

è€ŒHTTPé€šä¿¡çš„è¯·æ±‚ä½“/è¿”å›ä½“ï¼ˆ*Kubernetesèµ„æº*ï¼‰ä¸Kubernetesæºç ä¸­å¯¹åº”Goç±»å‹ï¼ˆ*kind*ï¼‰é—´çš„è½¬æ¢å¿…ç„¶æ¶‰åŠåˆ°åºåˆ—åŒ–/ååºåˆ—åŒ–ï¼ˆç¼–/è§£ç ï¼‰ã€‚
è€Œåœ¨Kubernetesæºç ä¸­ï¼Œ`apimachinery`åº“é™¤äº†æ˜¯Kubernetes APIç±»å‹ç³»ç»Ÿçš„åŸºçŸ³ï¼Œä¹Ÿæ‰¿è½½ç€å¯¹*Kubernetesèµ„æº*ç¼–/è§£ç çš„ä½¿å‘½ã€‚
`kube-apiserver`ï¼Œ`kubectl`ï¼Œ`client-go`ï¼Œ`kubelet`ç­‰ç»„ä»¶ã€å·¥å…·ä»¥åŠåº“éƒ½ä¾èµ–`apimachinery`åº“æ¥å¯¹èµ„æºè¿›è¡Œç¼–/è§£ç ã€‚



åœ¨æœ¬èŠ‚ä¸­æˆ‘ä»¬å°†æ·±å…¥ä»‹ç»ä¸€ä¸‹`apimachinery`åº“ä¸­çš„åºåˆ—åŒ–å™¨å’Œåºåˆ—åŒ–å·¥å‚ã€‚ å…¶å®`apimachinery`åº“ä¸ç¼–/è§£ç ç›¸å…³çš„é€»è¾‘ç›¸å¯¹å¤æ‚ã€‚
å› æ­¤ï¼Œä¸ºäº†å‡è½»è¯»è€…çš„è´Ÿæ‹…ä¹Ÿä¾¿äºè¯»è€…ç†è§£ï¼Œæˆ‘ä»¬ä¸ä¼šç…§æ¬å¤§æ®µæºç å¹¶åšè¡Œçº§åˆ«çš„è§£é‡Šã€‚
åœ¨æœ¬èŠ‚ä¸­æˆ‘ä»¬å°†ä½¿ç”¨æˆ‘ä»¬è®¤ä¸ºåˆé€‚çš„ç¼–æ’æ–¹å¼æ¥ä¸ºè¯»è€…æ­å¼€`apimachinery`ä¸­ç¼–/è§£ç ä½“ç³»çš„é¢çº±ã€‚

:::tip æ³¨

ä¸ºäº†ä¾¿äºè¯»è€…ç†è§£Kubernetesçš„ç¼–/è§£ç ä½“ç³»ï¼Œæœ¬å°èŠ‚æ¥ä¸‹æ¥çš„å†…å®¹åŸºäº[Kubernetes v1.2.0-alpha.7](https://github.com/kubernetes/kubernetes/tree/v1.2.0-alpha.7)åŠå…¶ä¹‹å‰çš„ç‰ˆæœ¬ã€‚è¿™äº›ç‰ˆæœ¬æœ‰åŠ©äºæˆ‘ä»¬äº†è§£Kuberneteså¦‚ä»Šç›¸å¯¹å¤æ‚çš„ç¼–/è§£ä½“ç³»æ˜¯å¦‚ä½•ä¸€æ­¥æ­¥æ¼”åŒ–è€Œæ¥çš„ã€‚
å½¼æ—¶ï¼Œ`apimachinery`åº“è¿˜æ²¡æœ‰æ­£å¼ç‹¬ç«‹ï¼Œå½“æ—¶æ‰€æœ‰ç¼–/è§£ç é€»è¾‘è¿˜è€¦åˆåœ¨äº†`kubernetes`åº“å†…ã€‚

ç›´åˆ°[Kubernetes v1.6.0-alpha.1](https://github.com/kubernetes/kubernetes/tree/v1.6.0-alpha.1)(<GithubSVG /> [Pull Request #39475](https://github.com/kubernetes/kubernetes/pull/39475))ï¼Œç¤¾åŒºæ‰æ­£å¼ç‹¬ç«‹å‡º`apimachinery`åº“ã€‚
åŸå…ˆ`kubernetes`åº“ä¸­ä¸APIç±»å‹ç³»ç»Ÿç›¸å…³çš„ä»£ç ï¼ˆåŒ…æ‹¬ç¼–/è§£ç é€»è¾‘ç­‰ï¼‰è¢«æ•´ä½“è¿ç§»åˆ°äº†`apimachinery`åº“ä¸­ã€‚

å¦å¤–ï¼Œä¸ºäº†å‡è½»è¯»è€…é˜…è¯»è´Ÿæ‹…ï¼Œæˆ‘ä»¬å°†é‡ç‚¹èšç„¦åœ¨Kubernetesçš„è§£ç é€»è¾‘ï¼Œä¸å†èµ˜è¿°ç¼–ç é€»è¾‘ã€‚
:::


## èµ„æºçš„å†…éƒ¨ç‰ˆæœ¬

åœ¨ä¹‹å‰[åˆè¯†kind](./kubernetes-api#åˆè¯†kind)å°èŠ‚ï¼Œæˆ‘ä»¬å°±å·²ç»å¼ºè°ƒè¿‡ï¼Œæœ¬ä¹¦ä¸­æ‰€æåŠçš„åºåˆ—åŒ–/ååºåˆ—åŒ–ç‰¹æŒ‡**åœ¨Kubernetesä¸Šä¸‹æ–‡ä¸­**ã€‚

æˆ‘ä»¬çŸ¥é“ï¼Œåœ¨Goè¯­è¨€ä¸­ï¼ŒJSONç¼–ç çš„å­—èŠ‚åºåˆ—ï¼ˆ`[]byte`ï¼‰ä¸Goç±»å‹ï¼ˆ`struct`ï¼‰ä¹‹é—´çš„è½¬æ¢å…¶å®ååˆ†ç®€å•ï¼Œåªè¦åˆ©ç”¨æ ‡å‡†åº“`encoding/json`çš„`json.Unmarshal`ä»¥åŠ`json.Marshal`å°±å¯ä»¥è½»æ¾å®Œæˆã€‚

è€Œåœ¨Kubernetesä¸­ï¼Œå¯¹èµ„æºçš„ç¼–/è§£ç è¿˜åŒ…æ‹¬ä¸€äº›ç‰¹æ®Šçš„æœºåˆ¶ï¼Œè¿™äº›ç‰¹æœ‰çš„æœºåˆ¶ä¹Ÿå¯¼è‡´äº†`apimachinery`åº“ä¸­ç¼–/è§£ç ç›¸å…³ä»£ç çš„å¤æ‚æ€§ã€‚

è€Œè¿™äº›ç‰¹æ®Šæœºåˆ¶çš„æœ¬è´¨æ¥è‡ªäºKubernetesçš„ä¸­ä¸€ä¸ªç‰¹æ®Šæ¦‚å¿µâ€”â€”èµ„æºçš„*å†…éƒ¨ç‰ˆæœ¬ï¼ˆinternal/hub versionï¼‰*ã€‚

æ‰€è°“èµ„æºçš„*å†…éƒ¨ç‰ˆæœ¬*æ˜¯æŒ‡èµ„æºåœ¨`kube-apiserver`ç»„ä»¶å†…å­˜ä¸­çš„è¡¨ç°å½¢å¼ã€‚
æˆ‘ä»¬å…ˆå‰åœ¨[å†è¯†Kubernetesèµ„æº](./kubernetes-api#ä»kubernetes-kindåˆ°kubernetesèµ„æºå†è¯†kubernetesèµ„æº)å°èŠ‚å·²ç»ä»‹ç»è¿‡èµ„æºåœ¨Kubernetesç³»ç»Ÿä¸­çš„ä¸åŒè¡¨ç°å½¢å¼ï¼Œå†…å­˜å°±æ˜¯å…¶ä¸­ä¹‹ä¸€ã€‚
èµ„æºçš„å†…å­˜å½¢å¼æ˜¯æŒ‡Kubernetesç»„ä»¶ï¼ˆ`kube-apiserver`ï¼Œ`kubelet`ï¼Œ`kubectl`ç­‰ï¼‰åœ¨ååºåˆ—åŒ–JSONå/åºåˆ—åŒ–æˆJSONå‰çš„*kind*å®ä¾‹ï¼ˆinstanceï¼‰ã€‚è€Œå¯¹äºèµ„æºçš„*å†…éƒ¨ç‰ˆæœ¬*æ¥è¯´ï¼Œå®ƒç‰¹æŒ‡åœ¨**`kube-apiserver`ç»„ä»¶**ä¸­çš„å†…å­˜å½¢å¼ã€‚

æˆ‘ä»¬åœ¨[ä»Kubernetes APIè°ˆèµ·](./kubernetes-api)ä»¥åŠ[GVK](./gvk)å°èŠ‚å·²ç»å¤šæ¬¡å¼ºè°ƒäº†èµ„æºç‰ˆæœ¬è¿™ä¸ªé‡è¦æ¦‚å¿µï¼Œä¸è¿‡èµ„æºçš„å¤šç‰ˆæœ¬å¯¹äº`kube-apiserver`æ¥è¯´ï¼Œè¿™å´æ˜¯ä¸€ä¸ªç›¸å½“æ£˜æ‰‹çš„é—®é¢˜ã€‚
`kube-apiserver`ä»å¤„ç†HTTPè¯·æ±‚å¼€å§‹åˆ°æœ€ç»ˆå°†èµ„æºå­˜å…¥`etcd`ä¸­è¿™ä¸­é—´æœ‰ä¸€ç³»åˆ—æ­¥éª¤æµç¨‹éœ€è¦å®Œæˆï¼Œè¿™ä¸åœ¨æœ¬ä¹¦çš„è®¨è®ºèŒƒå›´ä¹‹å†…ï¼Œå¯¹æ­¤è¿‡ç¨‹æ„Ÿå…´è¶£çš„è¯»è€…å¯ä»¥å‚è€ƒæ‰©å±•é˜…è¯»[Kubernetes APIè¯·æ±‚çš„ç”Ÿå‘½å‘¨æœŸ](../intro#æ‰©å±•é˜…è¯»)ã€‚
æ€»ä¹‹ï¼Œå¯¹äº`kube-apiserver`ç»„ä»¶æ¥è¯´ï¼Œå¦‚æœä¸é’ˆå¯¹èµ„æºçš„å¤šç‰ˆæœ¬æƒ…å†µåŠ ä»¥é¢å¤–å¤„ç†ï¼Œè¿™æ„å‘³ç€å®ƒéœ€è¦ä¸ºèµ„æºçš„æ¯ä¸ªç‰ˆæœ¬é‡å†™ç›¸åŒçš„é€»è¾‘ï¼Œè¿™æ˜¾ç„¶ä¸æ˜¯ä¸€ä¸ªå¥½çš„æ–¹å¼ã€‚

å› æ­¤ï¼Œèµ„æºçš„*å†…éƒ¨ç‰ˆæœ¬*çš„æå‡ºæ˜¯ä¸ºäº†è§£å†³`kube-apiserver`åœ¨å¤„ç†èµ„æºå¤šç‰ˆæœ¬æ—¶çš„ç—›ç‚¹ã€‚ å…·ä½“æ¥è¯´ï¼Œ`kube-apiserver`åœ¨ååºåˆ—åŒ–HTTPè¯·æ±‚ä½“ä¸­çš„èµ„æºæ—¶ï¼Œä¼šå†å°†èµ„æºè½¬åŒ–ä¸º*å†…éƒ¨ç‰ˆæœ¬*è¿›è€Œå¯ä»¥**ç»Ÿä¸€**å¤„ç†ã€‚

:::tip èµ„æºå†…éƒ¨ç‰ˆæœ¬çš„å†å²

å…³äºèµ„æº*å†…éƒ¨ç‰ˆæœ¬*å¼•å…¥æœ€æ—©å¯ä»¥è¿½æº¯åˆ°[<GithubSVG /> Pull Request #565](https://github.com/kubernetes/kubernetes/pull/565)ã€‚
[<GithubSVG /> Pull Request #565](https://github.com/kubernetes/kubernetes/pull/565)é¦–æ¬¡å°†`apiVersion`å­—æ®µå¼•å…¥åˆ°*APIå¯¹è±¡*[^1]ä¸­ã€‚
æˆ‘ä»¬åœ¨[APIåˆ†ç»„å’Œç‰ˆæœ¬åŒ–](./kubernetes-api#apiåˆ†ç»„groupå’Œç‰ˆæœ¬åŒ–version)å°èŠ‚å°±ä»‹ç»äº†Kubernetesæºç è‡ªå…¬å¼€ä»¥æ¥APIå°±å¸¦æœ‰ç‰ˆæœ¬ä¿¡æ¯ã€‚ä½†æ˜¯ç›´åˆ°[<GithubSVG /> Pull Request #565](https://github.com/kubernetes/kubernetes/pull/565)æ‰å°†APIç‰ˆæœ¬ä¿¡æ¯åŒæ—¶åµŒå…¥è¿›APIå¯¹è±¡ä¸­ã€‚
å½“æ—¶Kubernetes APIæœ‰ä¸”ä»…æœ‰ä¸€ä¸ªç‰ˆæœ¬`v1beta1`ï¼Œ`kube-apiserver`æš´éœ²çš„æ‰€æœ‰APIçš„æ ¹è·¯å¾„ä¸º`api/v1beta1`ã€‚
åœ¨[<GithubSVG /> Pull Request #565](https://github.com/kubernetes/kubernetes/pull/565)ä¸­ï¼Œ
ä½œè€…å¸Œæœ›HTTPè¯·æ±‚ä½“åŒæ ·å¸¦æœ‰ç‰ˆæœ¬ä¿¡æ¯ï¼Œä¾‹å¦‚:

<details>
<summary>å¤æ—©çš„Kubernetes APIè¯·æ±‚</summary>

```bash
POST /api/v1beta1/pods
{
  "id": "test-pod",
  "kind": "Pod",
  # highlight-next-line
  "apiVersion": "v1beta1",
  "desiredState": {
    "manifest": {
      "version": "v1beta1",
      "id": "php",
      "containers": [{
        "name": "nginx",
        "image": "dockerfile/nginx",
        "ports": [{
          "containerPort": 80,
          "hostPort": 8080
        }],
        "livenessProbe": {
          "enabled": true,
          "type": "http",
          "initialDelaySeconds": 30,
          "httpGet": {
            "path": "/index.html",
            "port": "8080"
          }
        }
      }]
    }
  },
  "labels": {
    "name": "foo"
  }
}
```

</details>

è¿™æ ·åšçš„ç›®çš„æ˜¯èƒ½å¤Ÿå°†APIç‰ˆæœ¬å’ŒAPIå¯¹è±¡ä¸€ä¸€å¯¹åº”ï¼Œç‰¹åˆ«æ˜¯å°†æ¥åŒæ—¶å‡ºç°å¤šä¸ªAPIç‰ˆæœ¬çš„æ—¶å€™ã€‚

è€Œåœ¨[<GithubSVG /> Pull Request #565](https://github.com/kubernetes/kubernetes/pull/565)ä¹‹å‰ï¼Œ*APIå¯¹è±¡*å´æ²¡æœ‰ç‰ˆæœ¬çš„æ¦‚å¿µã€‚
å½“æ—¶çš„APIå¯¹è±¡ä¹Ÿåªæœ‰é›¶æ˜Ÿçš„å‡ ä¸ªï¼Œå®ƒä»¬çš„Goç±»å‹è¢«ç»Ÿä¸€å®šä¹‰åœ¨[<GithubSVG /> `pkg/api/types.go`](https://github.com/kubernetes/kubernetes/blob/69c483f6205a2b35bea970917aadd155b8b492b1/pkg/api/types.go)ä¸­ã€‚
åœ¨[<GithubSVG /> Pull Request #565](https://github.com/kubernetes/kubernetes/pull/565)ä¸­ï¼Œä½œè€…å¼•å…¥`apiVersion`å­—æ®µçš„åŒæ—¶ï¼Œè¿˜ä¸“é—¨æ–°å»ºäº†ä¸€ä¸ªç›®å½•ï¼ˆåŒ…ï¼‰ï¼š[<GithubSVG /> `pkg/api/v1beta1/`](https://github.com/kubernetes/kubernetes/tree/bf5ae4bb9ddea63847b229b300f1fc26c538a9d9/pkg/api/v1beta1)ï¼Œ
å¹¶å°†åŸæ¥`pkg/api/types.go`æ–‡ä»¶æ‹·ä¹Ÿè´åˆ°äº†`pkg/api/v1beta1/`ç›®å½•ä¸‹ã€‚è‡³æ­¤ï¼ŒKubernetesé¦–æ¬¡å‡ºç°äº†åŒæ—¶å­˜åœ¨**ä¸¤ä¸ª**ç‰ˆæœ¬çš„APIå¯¹è±¡çš„æƒ…å†µï¼š`v1beta1`ä»¥åŠåˆå§‹ç‰ˆæœ¬ï¼ˆå³ä¸å¸¦ç‰ˆæœ¬ä¿¡æ¯ï¼‰ã€‚ä¾‹å¦‚ï¼š`v1beta1.Pod`å’Œ`Pod`ã€‚ï¼ˆå½“ç„¶å®ƒä»¬ç›®å‰å”¯ä¸€çš„åŒºåˆ«æ˜¯`apiVersion`å­—æ®µä¸€ä¸ªä¸ºç©ºï¼Œå¦ä¸€ä¸ªåˆ™ä¸º`v1beta1`ã€‚ï¼‰
ä¸ºäº†å¤ç”¨åŸå…ˆå°±å·²ç»å­˜åœ¨çš„ä»£ç ï¼ˆè¿™äº›ä»£ç åŸºäº`pkg/api/types.go`ä¸­æ‰€å®šä¹‰çš„åˆå§‹APIå¯¹è±¡ï¼‰ï¼Œä½œè€…åŒæ—¶å¼•å…¥äº†[<GithubSVG /> `internalize()`](https://github.com/kubernetes/kubernetes/blob/bf5ae4bb9ddea63847b229b300f1fc26c538a9d9/pkg/api/helper.go#L268)å‡½æ•°ï¼Œç”¨äºå°†æ‰€æœ‰`v1beta1`çš„APIå¯¹è±¡è½¬åŒ–ä¸ºåˆå§‹APIå¯¹è±¡ï¼šä¾‹å¦‚å°†`v1beta1.Pod`è½¬åŒ–ä¸º`Pod`ã€‚
è¿™æ­£å¼èµ„æºç‰ˆæœ¬è½¬åŒ–çš„é›å½¢ï¼Œè€Œ`pkg/api/types.go`ä¸­å®šä¹‰çš„åˆå§‹APIå¯¹è±¡åˆ™å¯ä»¥è®¤ä¸ºæ˜¯å……å½“äº†Kubernetes APIå¯¹è±¡çš„**ç¬¬ä¸€ä¸ª**å†…éƒ¨ç‰ˆæœ¬ã€‚

åœ¨è¿™ä¸ªPRä¸­ï¼Œ[<GithubSVG /> `internalize()`](https://github.com/kubernetes/kubernetes/blob/bf5ae4bb9ddea63847b229b300f1fc26c538a9d9/pkg/api/helper.go#L268)å‡½æ•°è¿˜ååˆ†ç²—ç³™ï¼Œç”±äºå½“æ—¶APIå¯¹è±¡æœ¬èº«è¿˜ä¸å¤šï¼Œä½œè€…å‡ ä¹æšä¸¾äº†æ‰€æœ‰çš„è½¬æ¢ã€‚
åç»­çš„[<GithubSVG /> Pull Request #672](https://github.com/kubernetes/kubernetes/pull/672)å¯¹[`internalize()`](https://github.com/lavalamp/kubernetes/blob/ce586c1448ad37fb31f915d2fbeced96fec2cd61/pkg/api/helper.go#L467)å‡½æ•°è¿›è¡Œäº†ä¼˜åŒ–ï¼Œç¤¾åŒºå¼€å‘è€…é¦–æ¬¡å¼•å…¥äº†"ç‰ˆæœ¬è½¬åŒ–å‡½æ•°çš„æ³¨å†Œæœºåˆ¶"ï¼š

<details>
<summary>ç‰ˆæœ¬è½¬æ¢å‡½æ•°çš„æ³¨å†Œæœºåˆ¶</summary>

æ–°å¼•å…¥çš„`Converter`ç±»å‹æ˜¯ç‰ˆæœ¬è½¬æ¢å‡½æ•°çš„æ³¨å†Œæœºåˆ¶çš„è½½ä½“ï¼›

```go title="pkg/api/helper.go"
// Converter knows how to convert one type to another.
type Converter struct {
	// Map from the conversion pair to a function which can
	// do the conversion.
	// highlight-next-line
	funcs map[typePair]reflect.Value

	// ...
}

// Register registers a conversion func with the Converter. conversionFunc must take
// two parameters, the input and output type.
//
func (c *Converter) Register(conversionFunc interface{}) error {
	// ...
}
```

`Converter`ç»“æ„ä¸­çš„`funcs`æˆå‘˜å˜é‡æ˜¯è½¬æ¢å‡½æ•°çš„æ³¨å†Œè¡¨ã€‚`Converter`çš„`Register`å‡½æ•°ç”¨äºæ³¨å†Œè½¬åŒ–å‡½æ•°ï¼Œä¾‹å¦‚ï¼š
```go
c.Register(
        func(in *Pod, out *v1.Pod) error {
                // conversion logic...
                return nil
        })
```

æœ‰äº†`Converter`ä¹‹åï¼Œæˆ‘ä»¬å¯ä»¥å°†APIå¯¹è±¡ä¸åŒç‰ˆæœ¬é—´çš„è½¬åŒ–é€»è¾‘å°è£…æˆç‹¬ç«‹çš„å‡½æ•°ï¼Œç„¶åç»Ÿä¸€æ³¨å†Œè¿›`Converter`ä¸­ï¼Œ`internalize()`å‡½æ•°é€šè¿‡æŸ¥è¯¢æ­¤ç»“æ„çš„æ³¨å†Œè¡¨ç›´æ¥è°ƒç”¨ç›¸åº”çš„è½¬åŒ–å‡½æ•°æ¥å®ŒæˆAPIå¯¹è±¡ç‰ˆæœ¬çš„è½¬åŒ–ã€‚

</details>


å¯ä»¥è¯´[<GithubSVG /> Pull Request #565](https://github.com/kubernetes/kubernetes/pull/565)ä¸[<GithubSVG /> Pull Request #196](https://github.com/kubernetes/kubernetes/pull/196)ï¼ˆé¦–æ¬¡å°†`kind`å­—æ®µå¼•å…¥APIçš„JSON Schemaï¼‰ä¸€èµ·å¥ å®šäº†Kubernetes APIç±»å‹ç³»ç»Ÿçš„é›å½¢ã€‚

:::

ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬åªæ˜¯ä»‹ç»äº†`kube-apiserver`åœ¨æ¥å—åˆ°HTTPè¯·æ±‚åï¼Œä¼šå°†èµ„æºåºåˆ—åŒ–åè½¬åŒ–ä¸ºå…¶å†…éƒ¨ç‰ˆæœ¬ã€‚
å…¶å®åœ¨æ­¤ä¹‹åå†…éƒ¨ç‰ˆæœ¬è¿˜éœ€è¦å†è½¬åŒ–æˆå…¶*å­˜å‚¨ç‰ˆæœ¬*å­˜å…¥`etcd`ä¸­ã€‚
æ–‡æ¡£[API Changes <GithubSVG />](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api_changes.md#operational-overview)é‡Œç®€å•æ¦‚æ‹¬äº†èµ„æºåœ¨ä¸€æ¬¡HTTPè¯·æ±‚é‡Œæ‰€è¦ç»å†çš„å„æ¬¡è½¬åŒ–ï¼š
> 1. A user POSTs a Pod object to /api/v7beta1/...
> 2. The JSON is unmarshalled into a v7beta1.Pod structure
> 3. Default values are applied to the v7beta1.Pod
> 4. The v7beta1.Pod is converted to an hub.Pod internal version
> 5. The hub.Pod is validated, and any errors are returned to the user
> 6. The hub.Pod is converted to a v6.Pod (because v6 is the latest stable version)
> 7. The v6.Pod is marshalled into JSON and written to etcd

é™¤æ­¤ä»¥å¤–ï¼Œåœ¨HTTPè¯·æ±‚è¿”å›æ—¶ï¼Œè¿˜éœ€è¦å†å°†å†…éƒ¨ç‰ˆæœ¬è½¬åŒ–ä¸ºå‘é€æ—¶çš„ç‰ˆæœ¬è¿”å›ç»™å®¢æˆ·ç«¯ã€‚è¿™ä¸ªåå‘è½¬åŒ–çš„è¿‡ç¨‹æˆ‘ä»¬ä¸å†èµ˜è¿°ã€‚


[TODO]: # (éšç€Kubernetesä¸æ–­æ¼”åŒ–ï¼Œç‰ˆæœ¬è½¬åŒ–æœºåˆ¶çš„**ç†è®º**ä¹Ÿé€æ¸æˆç†Ÿï¼Œç®€å•æ¥è¯´ï¼Œåœ¨Kubernetesä¸­ï¼Œä»èµ„æºçš„Aç‰ˆæœ¬è½¬åŒ–ä¸ºBç‰ˆæœ¬ï¼šéœ€è¦å…ˆå°†Aç‰ˆæœ¬è½¬åŒ–ä¸ºå†…éƒ¨ç‰ˆæœ¬ï¼Œå†ä»å†…éƒ¨ç‰ˆæœ¬è½¬åŒ–ä¸ºBç‰ˆæœ¬ï¼›)

## Kubernetesç¼–/è§£ç ä½“ç³»æ¼”åŒ–å†å²


åœ¨æˆ‘çœ‹æ¥ï¼ŒKubernetesæ•´ä½“ç¼–/è§£ç ä½“ç³»çš„æ¼”åŒ–å’Œå½¢æˆå…±åˆ†ä¸ºå››ä¸ªé˜¶æ®µï¼š"å¤ä»£"ï¼Œ"è¿‘ä»£"[<GithubSVG /> Pull Request #196](https://github.com/kubernetes/kubernetes/pull/196)ï¼Œ"ç°ä»£" [<GithubSVG /> Pull Request #723](https://github.com/kubernetes/kubernetes/pull/723)ï¼Œ"å½“ä»£"[<GithubSVG /> Pull Request #17922](https://github.com/kubernetes/kubernetes/pull/17922)
Codecæ—¶æœŸä¹Ÿæ­£æ˜¯**ç°åœ¨**Kubernetesæ‰€ä½¿ç”¨çš„ç¼–/è§£ç ä½“ç³»ã€‚

### å¤ä»£é˜¶æ®µ

æ‰€è°“"å¤ä»£"æ˜¯æŒ‡è‡ªKubernetesæºç å…¬å¸ƒå¼€å§‹ï¼Œç¼–/è§£ç ç”šè‡³è¿˜æœªå½¢æˆä½“ç³»çš„æ—¶æœŸï¼Œ`kube-apiserver`åœ¨HTTPè¯·æ±‚çš„handlerä¸­ç›´æ¥ä½¿ç”¨`json.Marshal`å®Œæˆåºåˆ—åŒ–ã€‚


### è¿‘ä»£é˜¶æ®µ

"è¿‘ä»£"æ˜¯æŒ‡Kubernetesç¼–/è§£ç ä½“ç³»å¼€å§‹é€æ¸å½¢æˆçš„æ—¶æœŸã€‚è¿™ä¸ªæ—¶æœŸç¤¾åŒºå¼€å‘è€…ä¸ºKubernetesçš„ç¼–/è§£ç å¼•å…¥äº†ä¸€äº›å…³é”®æ€§çš„æœºåˆ¶ï¼Œè¿™äº›æœºåˆ¶ä¹Ÿä¸€ç›´è¢«æ²¿ç”¨è‡³ä»Šã€‚è¿™äº›æœºåˆ¶åŒ…æ‹¬ï¼š
1. [<GithubSVG /> Pull Request #196](https://github.com/kubernetes/kubernetes/pull/196)

   ä¼´éšç€`kind`å­—æ®µå¼•å…¥APIç±»å‹çš„åŒæ—¶ï¼Œ`Encode()/Decode()`å‡½æ•°ç”¨äºæ›¿ä»£`json.Marshal()/json.Unmarshal`ä¹Ÿæ­£å¼è¿›å…¥Kubernetesæºç ä¸­ï¼Œ ç¼–/è§£ç ä½“ç³»å¼€å§‹å¤„äºèŒèŠ½é˜¶æ®µã€‚
   å…·ä½“æ¥è¯´ï¼ŒPRä½œè€…å¼•å…¥äº†ä¸¤ä¸ªä¸ç¼–/è§£ç æœ‰å…³çš„æœºåˆ¶ï¼š
   - "æ™ºèƒ½æ¨æ–­"æœºåˆ¶â€”â€”åœ¨è§£ç çš„åˆå§‹é˜¶æ®µæ ¹æ®JSONå­—èŠ‚åºåˆ—çš„`kind`å­—æ®µæå‰è·å–APIç±»å‹ä¿¡æ¯ï¼›

     æˆ‘ä»¬åœ¨ä¹‹å‰[runtime.Schemeä¸kind](./runtime.Object#runtimeschemeä¸kind)å°èŠ‚åœ¨åªæ˜¯é¡ºå¸¦æåŠäº†è¿™ä¸ªè¿‡ç¨‹ï¼Œæˆ‘ä»¬åœ¨è¿™é‡Œå†å¤è¿°ä¸€ä¸‹å®ƒçš„åŸç†ï¼š
     ```go
     findKind := struct {
     	Kind string `json:"kind,omitempty" yaml:"kind,omitempty"`
     }{}
     err := yaml.Unmarshal(data, &findKind)
     ```
     åŸç†å…¶å®éå¸¸ç®€å•ï¼Œå…ˆåˆ›å»ºåªæœ‰ä¸€ä¸ª`Kind`å­—æ®µçš„ç©ºç»“æ„ä½“`findKind`ï¼Œå†å°è¯•å°†åŸå§‹å­—èŠ‚åºåˆ—`data`è§£ç ä¸º`findKind`ç»“æ„ï¼Œè¿™æ ·å°±å¯ä»¥ç‡å…ˆ"æ•è·"åŸå§‹å­—èŠ‚ä¸­åŒ…å«çš„`kind`ä¿¡æ¯ã€‚

   - "APIç±»å‹æ³¨å†Œ"æœºåˆ¶â€”â€”å°†æ‰€æœ‰çš„APIç±»å‹[^1]äº‹å…ˆæ³¨å†Œï¼Œåœ¨"æ™ºèƒ½æ¨æ–­"æœºåˆ¶è·å–APIç±»å‹ä¿¡æ¯åæŸ¥è¡¨ç›´æ¥è·å–APIç±»å‹ã€‚

     æˆ‘ä»¬åœ¨ä¹‹å‰[runtime.Schemeä¸kind](./runtime.Object#runtimeschemeä¸kind)å°èŠ‚å·²ç»è¾ƒä¸ºå®Œæ•´åœ°ä»‹ç»è¿‡è¿™ä¸ªæœºåˆ¶ï¼Œåœ¨è¿™é‡Œæˆ‘ä»¬ä¸å†èµ˜è¿°ã€‚



2. [<GithubSVG /> Pull Request #565](https://github.com/kubernetes/kubernetes/pull/565)

   ä¼´éšç€`apiVersion`å­—æ®µå¼•å…¥APIç±»å‹ï¼ŒAPIå¯¹è±¡çš„*å†…éƒ¨ç‰ˆæœ¬*çš„æ¦‚å¿µå¼€å§‹å‡ºç°ã€‚ç›¸åº”åœ°ï¼Œ"ç‰ˆæœ¬è½¬åŒ–"æœºåˆ¶ä¹Ÿå¼€å§‹æ­£å¼è¿›å…¥ç¼–/è§£ç æµç¨‹ã€‚

3. [<GithubSVG /> Pull Request #672](https://github.com/kubernetes/kubernetes/pull/672)

   åœ¨è¿™ä¸ªPRä¸­ï¼Œä½œè€…å¼•å…¥"ç‰ˆæœ¬è½¬åŒ–å‡½æ•°æ³¨å†Œ"æœºåˆ¶ï¼Œç”¨äºä¼˜åŒ–ç‰ˆæœ¬è½¬åŒ–æµç¨‹ï¼›

åœ¨"è¿‘ä»£"é˜¶æ®µï¼Œæ‰€æœ‰ç¼–/è§£ç ä»£ç è¢«æ”¾ç½®åœ¨`pkg/api/helper.go`ä¸­â€”â€”è¿™è¯´æ˜ç¼–/è§£ç åœ¨å½“æ—¶å¹¶æœªå¼•èµ·ç¤¾åŒºè¶³å¤Ÿçš„é‡è§†ã€‚


### ç°ä»£é˜¶æ®µï¼ˆSchemeå¤§ä¸€ç»Ÿæ—¶æœŸï¼‰

"ç°ä»£"é˜¶æ®µæ˜¯æŒ‡ä»[<GithubSVG /> Pull Request #723](https://github.com/kubernetes/kubernetes/pull/723)å¼€å§‹çš„æ—¶æœŸã€‚
åœ¨è¯¥PRä¸­ï¼Œä½œè€…å…¶å®æ²¡æœ‰å¼•å…¥æ–°çš„æœºåˆ¶æˆ–æ˜¯æ”¹åŠ¨åŸæ¥çš„ç¼–/è§£ç é€»è¾‘ï¼Œä½œè€…åªæ˜¯æŠŠåŸæ¥`pkg/api/helper.go`ä¸­åˆ†æ•£çš„ç¼–/è§£ç é€»è¾‘å’Œæœºåˆ¶æ•´ä½“è¿ç§»å¹¶å°è£…åˆ°äº†ä¸€ä¸ªå«åš`Scheme`çš„ç±»å‹ä¸­ã€‚åŒæ—¶åˆ é™¤äº†åŸå…ˆçš„`pkg/api/helper.go`æ–‡ä»¶ã€‚
æˆ‘ä»¬æŠŠ[<GithubSVG /> Pull Request #723](https://github.com/kubernetes/kubernetes/pull/723)å•ç‹¬æå‡åˆ°ä¸€ä¸ªé˜¶æ®µçš„åŸå› æ˜¯ï¼šç»è¿‡æ•´ç†åçš„ç¼–/è§£ç ä»£ç é€»è¾‘å¼‚å¸¸æ¸…æ™°ï¼Œä¸€ä¸ª`Scheme`ç±»å‹å›Šæ‹¬äº†"è¿‘ä»£"é˜¶æ®µæ‰€æ–­æ–­ç»­ç»­å¼•å…¥çš„å„ä¸ªæœºåˆ¶ã€‚

```go
// Scheme defines an entire encoding and decoding scheme.
type Scheme struct {
	// versionMap allows one to figure out the go type of an object with
	// the given version and name.
	versionMap map[string]map[string]reflect.Type

	// converter stores all registered conversion functions. It also has
	// default coverting behavior.
	converter *Converter

	// MetaInsertionFactory is used to create an object to store and retrieve
	// the version and kind information for all objects. The default uses the
	// keys "version" and "kind" respectively.
	MetaInsertionFactory MetaInsertionFactory
}
```
å…¶ä¸­ï¼š
* `MetaInsertionFactory`æˆå‘˜ç”¨äº"æ™ºèƒ½æ¨æ–­"æœºåˆ¶ï¼›
* `versionMap`æˆå‘˜ç”¨äº"APIç±»å‹æ³¨å†Œ"æœºåˆ¶ï¼›
* `converter`æˆå‘˜ç”¨äº"ç‰ˆæœ¬è½¬åŒ–"ã€‚


ä»¥ç»è¿‡æ•´ç†åçš„è§£ç å‡½æ•°ä¸ºä¾‹ï¼š

```go title="pkg/api/conversion/decode.go"
// Decode converts a YAML or JSON string back into a pointer to an api object.
// Deduces the type based upon the fields added by the MetaInsertionFactory
// technique. The object will be converted, if necessary, into the
// s.InternalVersion type before being returned. Decode will refuse to decode
// objects without a version, because that's probably an error.
func (s *Scheme) Decode(data []byte) (interface{}, error) {
	version, kind, err := s.DataVersionAndKind(data)
	if err != nil {
		return nil, err
	}
	if version == "" {
		return nil, fmt.Errorf("version not set in '%s'", string(data))
	}
	obj, err := s.NewObject(version, kind)
	if err != nil {
		return nil, err
	}
	// yaml is a superset of json, so we use it to decode here. That way,
	// we understand both.
	err = yaml.Unmarshal(data, obj)
	if err != nil {
		return nil, err
	}

	// Version and Kind should be blank in memory.
	err = s.SetVersionAndKind("", "", obj)
	if err != nil {
		return nil, err
	}

	// Convert if needed.
	if s.InternalVersion != version {
		objOut, err := s.NewObject(s.InternalVersion, kind)
		if err != nil {
			return nil, err
		}
		err = s.converter.Convert(obj, objOut, 0)
		if err != nil {
			return nil, err
		}
		obj = objOut
	}
	return obj, nil
}
```
è§£ç è¿‡ç¨‹å¯ä»¥æ¸…æ™°åœ°åˆ’åˆ†ä¸º5ä¸ªæ­¥éª¤ï¼š

1. æ™ºèƒ½æ¨æ–­

   è°ƒç”¨`DataVersionAndKind()`å‡½æ•°æ¨æ–­å­—èŠ‚åºåˆ—çš„`kind`å’Œ`apiVersion`ï¼ˆå½¼æ—¶ï¼ŒAPIåˆ†ç»„çš„æ¦‚å¿µè¿˜æ²¡æœ‰å‡ºç°ï¼‰ã€‚
2. åˆ›å»ºAPIå¯¹è±¡è½½ä½“

   è·å–APIå¯¹è±¡çš„ç±»å‹å’Œç‰ˆæœ¬ä¿¡æ¯åï¼Œè°ƒç”¨`NewObject()`åˆ›å»ºä¸€ä¸ªå¯¹åº”ç±»å‹å’Œç‰ˆæœ¬çš„APIå¯¹è±¡çš„"ç©ºè½½ä½“"ã€‚

3. ååºåˆ—åŒ–

   è°ƒç”¨`Unmarshal()`å°†å­—èŠ‚åºåˆ—åºåˆ—åŒ–åˆ°ä¸Šä¸€æ­¥åˆ›å»ºçš„APIå¯¹è±¡è½½ä½“ä¸­ï¼›
4. ç‰ˆæœ¬è½¬åŒ–

   * è°ƒç”¨`SetVersionAndKind()`å‡½æ•°å°†APIå¯¹è±¡çš„`apiVersion`å’Œ`kind`å­—æ®µè‡³ç©º;
   * è°ƒç”¨`NewObject()`åˆ›å»ºAPIå¯¹è±¡çš„å†…éƒ¨ç‰ˆæœ¬çš„"ç©ºè½½ä½“";
   * è°ƒç”¨`Convert()`å°†APIå¯¹è±¡è½¬åŒ–ä¸ºå…¶å†…éƒ¨ç‰ˆæœ¬ã€‚
5. è¿”å›å†…éƒ¨ç‰ˆæœ¬

å…¶ä¸­æœ‰ä¸€äº›ç»†èŠ‚éœ€è¦å•ç‹¬è¯´æ˜ï¼š
* `Scheme`çš„`NewObject()`æ–¹æ³•ç”¨äºåˆ›å»ºç»™å®šç±»å‹å’Œç‰ˆæœ¬çš„APIå¯¹è±¡çš„ç©º"è½½ä½“"ã€‚
   ```go
   // NewObject returns a new object of the given version and name,
   // or an error if it hasn't been registered.
   func (s *Scheme) NewObject(versionName, typeName string) (interface{}, error) {
   	if types, ok := s.versionMap[versionName]; ok {
   		if t, ok := types[typeName]; ok {
   			return reflect.New(t).Interface(), nil
   		}
   		return nil, fmt.Errorf("No type '%v' for version '%v'", typeName, versionName)
   	}
   	return nil, fmt.Errorf("No version '%v'", versionName)
   }
   ```
   å…·ä½“å®ç°ä¸Šå®ƒéœ€è¦æŸ¥è¯¢`versionMap`è¿™å¼ è¡¨ï¼Œåªæœ‰åœ¨è¿™å¼ è¡¨ä¸­æ³¨å†Œè¿‡çš„APIç±»å‹æ‰èƒ½è¢«åˆ›å»ºã€‚

* `Scheme`çš„`DataVersionAndKind()`æ–¹æ³•ç”¨äº"æ™ºèƒ½æ¨æ–­"ã€‚
  ```go
  // DataAPIVersionAndKind will return the APIVersion and Kind of the given wire-format
  // enconding of an API Object, or an error.
  func (s *Scheme) DataVersionAndKind(data []byte) (version, kind string, err error) {
  	findKind := s.MetaInsertionFactory.Create("", "")
  	// yaml is a superset of json, so we use it to decode here. That way,
  	// we understand both.
  	err = yaml.Unmarshal(data, findKind)
  	if err != nil {
  		return "", "", fmt.Errorf("couldn't get version/kind: %v", err)
  	}
  	version, kind = s.MetaInsertionFactory.Interpret(findKind)
  	return version, kind, nil
  }

  ```
  åœ¨å®ç°ä¸Šå®ƒä¾èµ–äº`MetaInsertionFactory`æˆå‘˜ã€‚å…·ä½“çš„æ™ºèƒ½æ¨ç†è¿‡ç¨‹åŸç†åŸºæœ¬ä¸"è¿‘ä»£"é˜¶æ®µä¸€è‡´ï¼Œæˆ‘ä»¬ä¸å†èµ˜è¿°ã€‚

ä¸‹å›¾æ€»ç»“äº†æ­¤æ—¶æœŸçš„è§£ç è¿‡ç¨‹ï¼ˆä¸åŒ…æ‹¬ç‰ˆæœ¬è½¬åŒ–ï¼‰ï¼š

 <SerializerBasicSVG style={{"width": "95%"}}/>



### å½“ä»£é˜¶æ®µ

Kuberneteså¦‚ä»Šä½¿ç”¨çš„ç¼–/è§£ç ä½“ç³»æ¥è‡ªäºä¸€æ¬¡é‡å¤§é‡æ„:ç›¸å…³ææ¡ˆ[<GithubSVG /> Issues #7111](https://github.com/kubernetes/kubernetes/issues/7111)åŠå®ç°[<GithubSVG /> Pull Request #17922](https://github.com/kubernetes/kubernetes/pull/17922)ã€‚
:::tip
å½“æ—¶Kubernetesç‰ˆæœ¬å·²ç»æ¥è¾¾äº†[v1.2.0-alpha.7](https://github.com/kubernetes/kubernetes/tree/v1.2.0-alpha.7)ï¼ŒKubernetes APIç±»å‹ç³»ç»Ÿï¼ˆ*èµ„æº*ï¼Œ*APIåˆ†ç»„*ï¼Œ*kind*ï¼Œ`runtime.Object`æ¥å£ï¼Œ*GVK*ç­‰ï¼‰å·²ç»åŸºæœ¬è¶‹å‘æˆç†Ÿã€‚
è€Œæ­¤å‰æˆ‘ä»¬æ‰€ä»‹ç»çš„ä¸‰ä¸ªé˜¶æ®µç”šè‡³éƒ½åœ¨Kubernetesä»“åº“æ‰“çš„ç¬¬ä¸€ä¸ªtag[v0.2](https://github.com/kubernetes/kubernetes/tree/v0.2)ä¹‹å‰ã€‚
:::

ç”±äº[<GithubSVG /> Pull Request #17922](https://github.com/kubernetes/kubernetes/pull/17922)å¥ å®šäº†å¦‚ä»Šçš„Kubernetesç¼–/è§£ç ä½“ç³»ï¼Œå¹¶ä¸”åœ¨å†…å®¹ä¸Šè¿›è¡Œäº†å¤§é‡çš„é‡æ„ã€‚æˆ‘ä»¬å°†æŠŠå®ƒæ”¾åœ¨å•ç‹¬çš„å°èŠ‚ä»‹ç»ã€‚


## Codecä½“ç³»

åœ¨ææ¡ˆ[<GithubSVG /> Issue #7111](https://github.com/kubernetes/kubernetes/issues/7111)ä¸­ï¼Œä½œè€…å†³å®šå°†`Scheme`è§£è€¦:

<details>
<summary>ææ¡ˆä¸­ä½œè€…å†³å®šè§£è€¦Schemeçš„åŠ¨æœº</summary>

> A runtime.Scheme combines a few concepts:
>
> * A registry of APIVersion -> Kind string -> Go object
> * A library of conversion routines which includes APIVersion -> Go object as well as Go object -> Go object
> * An encoding mechanism based around JSON
>
> In order to better support multiple API patterns grouped together (Kubernetes user API, Kubelet API, OpenShift API, future extension API) these assumptions will start to break down.

</details>


åŒæ—¶ä½œè€…ä¹Ÿç»™å‡ºäº†é‡æ„çš„å¤§è‡´æ–¹å‘ä¸è¦è§£å†³çš„é—®é¢˜ï¼š

<details>
<summary>ææ¡ˆä¸­ä½œè€…åˆ—ä¸¾é‡æ„éœ€è¦è§£å†³çš„é—®é¢˜</summary>

> Types of problems we want to solve:
> 1. It should be possible to take arbitrary serialized data and convert it to a versioned Go struct - call this "marshalling/unmarshalling". The interface for this is a `Codec`. There may be many codecs.
>    1. Where possible, we want to reuse the underlying infrastructure for marshaling and unmarshalling that exists in go - "encoding/json" / "encoding/gob" / "protobufs" efficiently.
>    2. It's likely that there exists one canonical "marshaller" for most objects, but there may be alternate mechanisms. For example, JSON is canonical for Kube, but we may occasionally want to marshal an annotated YAML object that has description comments for each field interleaved.
>    3. There are places where we want to convert `map[string]interface{}` (generic JSON object representation) or a `map[string][]string` (url.Values) into a versioned Go struct, which is dependent on a type of marshaling (i.e. following JSON rules, or Query parameter rules).
> 2. It should be possible to convert a versioned Go struct into a different versioned Go struct (typically by going to an intermediate format) on the server. This is "object versioning".
>    1. "Object versioning" requires the registration of an object Kind into an APIVersion for a specific API group. This was the original intent of runtime.Scheme.
> 3. It should be possible to convert arbitrary Go structs to different Go structs. This is "conversion".
>    1. Object versioning is a specific subset of conversion
>    2. We should try to make conversion less dependent on scheme?

</details>


æ€»ç»“æ¥è¯´ï¼Œä½œè€…å†³å®šå°†ç¼–/è§£ç é€»è¾‘æ•´ä½“ä»`Scheme`ä¸­å‰¥ç¦»ï¼Œå¹¶ä¿ç•™`Scheme`ç±»å‹çš„"APIç±»å‹æ³¨å†Œ"æœºåˆ¶ï¼ŒåŒæ—¶å¯ç”¨`Codec`æ¦‚å¿µä¸“é—¨ç”¨äºè´Ÿè´£ç¼–/è§£ç ã€‚
å› æ­¤ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥æŠŠKubernetes"å½“ä»£"ç¼–/è§£ç ä½“ç³»ç§°ä¸º"Codecä½“ç³»"ã€‚


### æ¥å£

åœ¨ä¸Šè¿°ææ¡ˆçš„å®ç°[<GithubSVG /> Pull Request #17922](https://github.com/kubernetes/kubernetes/pull/17922)ä¸­ï¼Œä½œè€…é¦–å…ˆæŠ½è±¡äº†ä¸€ç³»åˆ—æ¥å£ï¼š`Encoder`ï¼Œ`Decoder`ï¼Œ`Codec`ï¼Œ `NegotiatedSerializer`ï¼š
* `Encoder`â€”â€”*ç¼–ç å™¨*æ¥å£ï¼š

   åœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬ä¸å…³æ³¨ç¼–ç è¿‡ç¨‹ã€‚

* `Decoder`â€”â€”*è§£ç å™¨*æ¥å£ï¼š
  ```go
  type Decoder interface {
  	// Decode attempts to deserialize the provided data using either the innate typing of the scheme or the
  	// default kind, group, and version provided. It returns a decoded object as well as the kind, group, and
  	// version from the serialized data, or an error. If into is non-nil, it will be used as the target type
  	// and implementations may choose to use it rather than reallocating an object. However, the object is not
  	// guaranteed to be populated. The returned object is not guaranteed to match into. If defaults are
  	// provided, they are applied to the data by default. If no defaults or partial defaults are provided, the
  	// type of the into may be used to guide conversion decisions.
  	Decode(data []byte, defaults *unversioned.GroupVersionKind, into Object) (Object, *unversioned.GroupVersionKind, error)
  }
  ```

  `Decoder`æ¥å£æ‰€æè¿°çš„è§£ç å‡½æ•°ç­¾åä¸"è¿‘ä»£"å’Œ"ç°ä»£"é˜¶æ®µçš„è§£ç å‡½æ•°ç­¾åäº§ç”Ÿäº†è¾ƒå¤§çš„åŒºåˆ«ã€‚
  "è¿‘ä»£"å’Œ"ç°ä»£"é˜¶æ®µæ‰€ç”¨çš„è§£ç å‡½æ•°ç­¾åå…¶å®é€šä¿—å¸¸è§ï¼š`func Decode(data []byte) (interface{}, error)`ã€‚
  é™¤äº†åŸå§‹å­—èŠ‚åºåˆ—æ•°æ®`data`è¿™ä¸ªå‚æ•°ä»¥å¤–ï¼Œè¿˜éœ€è¦æä¾›`defaults`ä»¥åŠ`into`ä¸¤ä¸ªå‚æ•°ã€‚è¿™æ ·è®¾è®¡è§£ç æ–¹æ³•çš„åŠ¨æœºæ˜¯å¸¦æ¥äº†æ›´å¤šçš„çµæ´»æ€§ã€‚
  PRä½œè€…å¸Œæœ›è§£ç å™¨ï¼š
  1. å¦‚æœè°ƒç”¨è€…å·²ç»é¢„å…ˆæä¾›äº†è§£ç åçš„*kind*"ç©ºè½½ä½“"ï¼ˆ`into`ï¼‰ï¼Œè§£ç å™¨åº”è¯¥å°½é‡ä½¿ç”¨è°ƒç”¨è€…æä¾›çš„è½½ä½“è€Œé¿å…åœ¨å†…å­˜ä¸­å†åˆ†é…ä¸€ä¸ªæ–°å¯¹è±¡ï¼›
  2. é€šè¿‡åŸå§‹å­—èŠ‚åºåˆ—ï¼ˆ`data`ï¼‰åŒ…å«çš„GVKä¿¡æ¯ã€è°ƒç”¨è€…é»˜è®¤æä¾›çš„GVKä¿¡æ¯ï¼ˆ`defaults`ï¼‰ã€è°ƒç”¨è€…æä¾›çš„"ç©ºè½½ä½“"ï¼ˆ`into`ï¼‰ä¸­åŒ…å«çš„GVKä¿¡æ¯å…±åŒæ¨æ–­å‡ºä¸€ä¸ªå¯èƒ½çš„GVKã€‚

  :::tip æ³¨
  è¿™æ ·è®¾è®¡çš„ä¸€ä¸ªå¥½å¤„æ˜¯å¯¹äºåŸå§‹å­—èŠ‚æ•°æ®ä¸¢å¤±æˆ–GVKä¿¡æ¯æ®‹ç¼ºçš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡è°ƒç”¨è€…æä¾›çš„GVKä¿¡æ¯ï¼ˆ`defaults`ï¼‰ç”šè‡³æ˜¯`into`çš„GVKä¿¡æ¯å…œåº•ã€‚
  å½“ç„¶ï¼Œè¿™ç§çµæ´»æ€§ä¹Ÿå¸¦æ¥äº†å®ç°ä¸Šçš„ä¸æ–¹ä¾¿ã€‚å°¤å…¶æ˜¯åŸå§‹æ•°æ®åŒ…å«çš„å®é™…GVKä¿¡æ¯å’Œè°ƒç”¨è€…æä¾›çš„GVKä¿¡æ¯ä»¥åŠ`into`çš„GVKä¸ä¸€è‡´çš„æƒ…å†µã€‚
  å› æ­¤åœ¨è§£ç å™¨æ¥å£çš„å®ç°ä¸­ï¼ˆä¾‹å¦‚æˆ‘ä»¬åç»­ä»‹ç»çš„[JSONåºåˆ—åŒ–å™¨](# TODO: reference)ï¼‰ï¼Œæœ‰ç›¸å½“ä¸€éƒ¨åˆ†é€»è¾‘åœ¨å¤„ç†è¿™ç§æƒ…å½¢ã€‚
  :::


* `Codec`â€”â€”*ç¼–è§£ç¼–ç å™¨*æ¥å£ï¼š
  ```go
  // Codec defines methods for serializing and deserializing API objects.
  type Codec interface {
  	Decoder
  	Encoder
  }
  ```

  `Codec`æ¥å£æŠ½è±¡äº†å®ç°ç±»éœ€è¦åŒæ—¶å…·å¤‡ç¼–ç ä»¥åŠè§£ç èƒ½åŠ›ã€‚

* `NegotiatedSerializer`â€”â€”*åå•†åºåˆ—åŒ–å™¨*æ¥å£ï¼š

  ```go
  // NegotiatedSerializer is an interface used for obtaining encoders, decoders, and serializers
  // for multiple supported media types.
  type NegotiatedSerializer interface {
  	SupportedMediaTypes() []string
  	SerializerForMediaType(mediaType string, options map[string]string) (Serializer, bool)
  	EncoderForVersion(serializer Serializer, gv unversioned.GroupVersion) Encoder
  	DecoderToVersion(serializer Serializer, gv unversioned.GroupVersion) Decoder
  }
  ```
  PRä½œè€…ç”¨*Negotiated(åå•†)*å‘½åæ­¤æ¥å£çš„åŠ¨æœºæ­£å¼æ¥è‡ªäº[*HTTPå†…å®¹åå•†ï¼ˆHTTP Content negotiationï¼‰*](https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation)ã€‚
  ç®€å•æ¥è¯´ï¼Œ*HTTPå†…å®¹åå•†*æ˜¯æŒ‡æœåŠ¡ç«¯ä¸å®¢æˆ·ç«¯"åå•†"è¿”å›èµ„æºçš„å…·ä½“è¡¨ç¤ºå½¢å¼çš„ä¸€ç§æœºåˆ¶ã€‚
  ä¾‹å¦‚ï¼Œæ ¹æ®æ–‡æ¡£[Kubernetes API Concepts <KubernetesSVG />](https://kubernetes.io/docs/reference/using-api/api-concepts)ï¼Œ`kube-apiserver`é™¤äº†æ”¯æŒè¿”å›èµ„æºçš„JSONç¼–ç æ ¼å¼å¤–ï¼Œä¹Ÿæ”¯æŒè¿”å›èµ„æºçš„protobufç¼–ç æ ¼å¼ï¼š

  > [Alternate representations of resources](https://kubernetes.io/docs/reference/using-api/api-concepts/#alternate-representations-of-resources)
  >
  > List all of the pods on a cluster in Protobuf format.
  > ```bash
  > GET /api/v1/pods
  > # highlight-next-line
  > Accept: application/vnd.kubernetes.protobuf
  > ---
  > 200 OK
  > # highlight-next-line
  > Content-Type: application/vnd.kubernetes.protobuf
  >
  > ... binary encoded PodList object
  > ```

  å› æ­¤ï¼Œ*åå•†åºåˆ—åŒ–å™¨*æ¥å£æ‰€è¦æŠ½è±¡çš„èƒ½åŠ›æ˜¯æ”¯æŒåŒæ—¶å¯¹å¤šç§æ•°æ®æ ¼å¼çš„ç¼–/è§£ç ã€‚æ­£å¦‚ä½œè€…åœ¨ææ¡ˆ[<GithubSVG /> Issue #7111](https://github.com/kubernetes/kubernetes/issues/7111)ä¸­æè¿°çš„é‚£æ ·ï¼š
  > It's likely that there exists one canonical "marshaller" for most objects, but there may be alternate mechanisms. For example, JSON is canonical for Kube, but we may occasionally want to marshal an annotated YAML object that has description comments for each field interleaved.

  å…·ä½“æ¥è¯´ï¼š
  * `SupportedMediaTypes()`æè¿°äº†å®ç°ç±»éœ€è¦è¿”å›æ­¤åºåˆ—åŒ–å™¨æ”¯æŒçš„æ‰€æœ‰ç¼–ç æ ¼å¼ï¼›
  * `SerializerForMediaType()`æè¿°äº†å®ç°ç±»å¯ä»¥æ ¹æ®æŒ‡å®šçš„ç¼–ç æ ¼å¼è¿”å›å¯¹åº”çš„åºåˆ—åŒ–å™¨ï¼›

  *åå•†åºåˆ—åŒ–å™¨*é™¤äº†å¯ä»¥"åå•†"ç¼–ç æ ¼å¼ä»¥å¤–ï¼Œ**å®ƒçš„å¦ä¸€ä¸ªç‰¹ç‚¹æ˜¯æ”¯æŒ"åå•†"ç‰ˆæœ¬è½¬åŒ–æ—¶çš„ç›®æ ‡ç‰ˆæœ¬**ã€‚
  æˆ‘ä»¬ç°åœ¨å·²ç»çŸ¥é“ç¼–/è§£ç ä½“ç³»çš„"ç°ä»£"é˜¶æ®µï¼Œç¼–/è§£ç æ—¶é»˜è®¤è½¬åŒ–ä¸ºå…¶å†…éƒ¨ç‰ˆæœ¬ã€‚è€Œåœ¨è¿™æ¬¡é‡æ„ä¸­ï¼Œä½œè€…å†³å®šæ”¯æŒä»»æ„ä¸åŒç‰ˆæœ¬ä¹‹é—´çš„è½¬åŒ–ï¼Œæ­£å¦‚ä½œè€…åœ¨ææ¡ˆ[<GithubSVG /> Issue #7111](https://github.com/kubernetes/kubernetes/issues/7111)ä¸­æè¿°çš„é‚£æ ·ï¼š
  > It should be possible to convert a versioned Go struct into a different versioned Go struct (typically by going to an intermediate format) on the server.
  > This is "object versioning".

  å…·ä½“æ¥è¯´:
  * `EncoderForVersion()/DecoderToVersion()`è¡¨ç¤ºå®ç°ç±»å¯ä»¥æ ¹æ®æŒ‡å®šçš„ç›®æ ‡ç‰ˆæœ¬è¿”å›ä¸€ä¸ªä¸“é—¨è½¬åŒ–ä¸ºè¯¥ç›®æ ‡ç‰ˆæœ¬çš„ç¼–è§£ç å™¨ï¼›


  å¦å¤–ï¼Œç›¸æ¯”äºä¹‹å‰çš„å‡ ä¸ªæ¥å£åå‘åº•å±‚ï¼Œ*åå•†åºåˆ—åŒ–å™¨*æ¥å£å·²ç»æ˜¯**åº”ç”¨å±‚**çº§åˆ«çš„å°è£…ã€‚
  `client-go`ä½œä¸ºå®¢æˆ·ç«¯åº“ï¼Œå®ƒæ‰€ä½¿ç”¨çš„ç¼–è§£ç å™¨æ­£æ˜¯åå•†åºåˆ—åŒ–å™¨ã€‚[ğŸˆ](../intro#çº¦å®š)


### å®ç°

ä»‹ç»å®Œæ¥å£ä¹‹åï¼Œæˆ‘ä»¬æ¥ä¸‹æ¥çœ‹ä½œè€…æ˜¯å¦‚ä½•å®ç°è¿™äº›æ¥å£çš„ã€‚

#### JSONåºåˆ—åŒ–å™¨

ä½œè€…åœ¨[<GithubSVG /> Pull Request #17922](https://github.com/kubernetes/kubernetes/pull/17922)ä¸­åŒæ—¶æä¾›äº†JSONå’ŒYAMLä¸¤ç§åºåˆ—åŒ–å™¨çš„å®ç°ã€‚

æˆ‘ä»¬ä»¥JSONç¼–è§£ç å™¨ä¸ºä¾‹ï¼Œå®ƒå®ç°çš„æ¥å£æ˜¯`Codec`ã€‚
```go

type Serializer struct {
	meta    MetaFactory
	creater runtime.ObjectCreater
	typer   runtime.Typer
	yaml    bool
	pretty  bool
}
```
å…¶ä¸­ï¼Œ
* `meta`æˆå‘˜ç”¨äº"æ™ºèƒ½æ¨æ–­"ï¼Œå®ƒæ¼”åŒ–äº"ç°ä»£"æ—¶æœŸçš„`MetaInsertionFactory`ã€‚
* `creater`æˆå‘˜ç”¨äºæ ¹æ®ç»™å®šçš„GVKä¸‰å…ƒç»„åˆ›å»ºå¯¹åº”*kind*ï¼ˆç©ºï¼‰å®ä¾‹ã€‚
* `typer`æˆå‘˜ç”¨äºåˆ¤å®šä¸€ä¸ªç»™å®šçš„APIå¯¹è±¡æ˜¯å¦æ³¨å†Œè¿‡ã€‚

:::tip æ³¨
å°½ç®¡åœ¨ææ¡ˆ[<GithubSVG /> Issue #7111](https://github.com/kubernetes/kubernetes/issues/7111)ä¸­ï¼Œä½œè€…è™½ç„¶å†³å®šæŠŠç¼–/è§£ç é€»è¾‘ä»`Scheme`ç±»å‹ä¸­å‰¥ç¦»ï¼Œä½†æ˜¯ä½œè€…ä»ç„¶æœ‰æ„ä¿ç•™äº†`Scheme`"APIå¯¹è±¡æ³¨å†Œ"æœºåˆ¶ã€‚æ­£å¦‚ä½œè€…æåˆ°çš„é‚£æ ·ï¼š

> "Object versioning" requires the registration of an object Kind into an APIVersion for a specific API group.
> This was the original intent of runtime.Scheme.

ä»[<GithubSVG /> Pull Request #17922](https://github.com/kubernetes/kubernetes/pull/17922)ä¹‹åï¼Œ`Scheme`ç±»å‹ä»…ä»…è¢«ç”¨äºï¼š
* æ³¨å†Œæ‰€æœ‰çš„*kind*ï¼ˆAPIå¯¹è±¡ï¼‰ï¼›
* åˆ¤å®šç»™å®šçš„*kind*ï¼ˆAPIå¯¹è±¡ï¼‰æ˜¯å¦æ³¨å†Œï¼›
* æ ¹æ®ç»™å®šçš„GVKä¸‰å…ƒç»„åˆ›å»ºå¯¹åº”*kind*ï¼ˆAPIå¯¹è±¡ï¼‰çš„ç©ºå®ä¾‹ï¼ˆ"è½½ä½“"ï¼‰ã€‚

æ‰€ä»¥åœ¨Kubernetesæºç ä¸­ï¼ŒJSONåºåˆ—åŒ–å™¨åœ¨åˆå§‹åŒ–`creater`ï¼Œ`typer`æˆå‘˜æ—¶ä½¿ç”¨çš„æ˜¯`Scheme`å¯¹è±¡ã€‚**æ‰€ä»¥JSONåºåˆ—åŒ–å™¨ä»ç„¶ä¾èµ–`Scheme`çš„æ³¨å†Œæœºåˆ¶å·¥ä½œ**ã€‚
:::


æˆ‘ä»¬ä»…å…³æ³¨å®ƒçš„è§£ç è¿‡ç¨‹ï¼š
:::tip æ³¨
ä¸ºäº†å‡è½»è¯»è€…çš„è´Ÿæ‹…ä¹Ÿä¾¿äºè¯»è€…ç†è§£ï¼ŒåŒæ—¶ä¹Ÿä¸ºäº†èšç„¦ååºåˆ—åŒ–é€»è¾‘çš„ä¸»å¹²æ­¥éª¤ï¼Œä¸‹é¢çš„ä»£ç çœç•¥äº†ä¸€äº›ç»†ææœ«èŠ‚ã€‚
:::

```go
// Decode attempts to convert the provided data into YAML or JSON, extract the stored schema kind, apply the provided default gvk, and then
// load that data into an object matching the desired schema kind or the provided into. If into is *runtime.Unknown, the raw data will be
// extracted and no decoding will be performed. If into is not registered with the typer, then the object will be straight decoded using
// normal JSON/YAML unmarshalling. If into is provided and the original data is not fully qualified with kind/version/group, the type of
// the into will be used to alter the returned gvk. On success or most errors, the method will return the calculated schema kind.
func (s *Serializer) Decode(originalData []byte, gvk *unversioned.GroupVersionKind, into runtime.Object) (runtime.Object, *unversioned.GroupVersionKind, error) {
	// ...

	data := originalData

	// ...

	actual, err := s.meta.Interpret(data)
	if err != nil {
		return nil, nil, err
	}

	if gvk != nil {
		// apply kind and version defaulting from provided default
		if len(actual.Kind) == 0 {
			actual.Kind = gvk.Kind
		}
		if len(actual.Version) == 0 && len(actual.Group) == 0 {
			actual.Group = gvk.Group
			actual.Version = gvk.Version
		}
		if len(actual.Version) == 0 && actual.Group == gvk.Group {
			actual.Version = gvk.Version
		}
	}

	// ...

	if into != nil {
		typed, _, err := s.typer.ObjectKind(into)
		switch {
		case runtime.IsNotRegisteredError(err):
			if err := codec.NewDecoderBytes(data, new(codec.JsonHandle)).Decode(into); err != nil {
				return nil, actual, err
			}
			return into, actual, nil
		case err != nil:
			return nil, actual, err
		default:
			if len(actual.Kind) == 0 {
				actual.Kind = typed.Kind
			}
			if len(actual.Version) == 0 && len(actual.Group) == 0 {
				actual.Group = typed.Group
				actual.Version = typed.Version
			}
			if len(actual.Version) == 0 && actual.Group == typed.Group {
				actual.Version = typed.Version
			}
		}
	}

	if len(actual.Kind) == 0 {
		return nil, actual, runtime.NewMissingKindErr(string(originalData))
	}
	if len(actual.Version) == 0 {
		return nil, actual, runtime.NewMissingVersionErr(string(originalData))
	}

	// use the target if necessary
	obj, err := runtime.UseOrCreateObject(s.typer, s.creater, *actual, into)
	if err != nil {
		return nil, actual, err
	}

	if err := codec.NewDecoderBytes(data, new(codec.JsonHandle)).Decode(obj); err != nil {
    	return nil, actual, err
    }

	return obj, actual, nil
}
```

JSONåºåˆ—åŒ–å™¨çš„è§£ç è¿‡ç¨‹å¯ä»¥å¤§è‡´åˆ’åˆ†ä¸º5ä¸ªæ­¥éª¤ï¼š

1. æ™ºèƒ½æ¨æ–­

   è·å–åŸå§‹å­—èŠ‚åºåˆ—ï¼ˆ`originalData`ï¼‰ä¸­çš„GVKä¿¡æ¯ã€‚
2. **å…±åŒ**æ¨æ–­

   åˆ©ç”¨`originalData`ã€`gvk`ã€`into`ä¸­çš„GVKä¿¡æ¯å…±åŒæ¨æ–­å‡ºä¸€ä¸ªGKVä¸‰å…ƒç»„ã€‚
   è¡¥å…¨é¡ºåºä¸ºåŸå§‹å­—èŠ‚æ•°æ®åŒ…å«çš„GVKä¿¡æ¯ä¼˜å…ˆäºè°ƒç”¨è€…ç»™å®šçš„GVKä¿¡æ¯ï¼ˆå‚æ•°`gvk`ï¼‰ä¼˜å…ˆäºè°ƒç”¨è€…æä¾›çš„ç›®æ ‡å¯¹è±¡è½½ä½“ï¼ˆå‚æ•°`into`ï¼‰ã€‚
3. åˆ›å»º/å¤ç”¨"è½½ä½“"

   è°ƒç”¨`UseOrCreateObject`åˆ›å»ºä¸€ä¸ªæ–°çš„å¯¹è±¡"è½½ä½“"æˆ–è€…ä½¿ç”¨è°ƒç”¨è€…æä¾›çš„`into`ä½œä¸º"è½½ä½“"ã€‚
   å…·ä½“è§„åˆ™ä¸ºï¼šå¦‚æœå…±åŒæ¨æ–­å‡ºçš„GVKä¸‰å…ƒç»„ä¸`into`æ‰€æºå¸¦çš„GVKä¿¡æ¯ä¸åŒ¹é…ï¼Œé‚£ä¹ˆå°†ä¼šåˆ›å»ºå‡ºä¸€ä¸ªä¸æ¨æ–­GVKåŒ¹é…çš„å¯¹è±¡åšä¸ºç›®æ ‡"è½½ä½“"ï¼›
4. ååºåˆ—åŒ–

5. è¿”å›åºåˆ—åŒ–åçš„å¯¹è±¡ä»¥åŠ**å…±åŒæ¨æ–­çš„GVKä¸‰å…ƒç»„**


#### codec

æˆ‘ä»¬å¯ä»¥çœ‹å‡ºJSONåºåˆ—åŒ–å™¨çš„è§£ç è¿‡ç¨‹ä¸"ç°ä»£"æ—¶æœŸçš„è§£ç è¿‡ç¨‹äº§ç”Ÿäº†ä¸€äº›åŒºåˆ«ï¼š
1. å¤šäº†"å…±åŒæ¨æ–­"çš„æ­¥éª¤
2. å°‘äº†"ç‰ˆæœ¬è½¬åŒ–"çš„æ­¥éª¤

å¯¹äºå¤šå‡ºçš„"å…±åŒæ¨æ–­"æ­¥éª¤å…¶å®æ˜¯å®¹æ˜“ç†è§£çš„ï¼Œæ¯•ç«Ÿæ­¤æ—¶`Decode()`æ–¹æ³•ç­¾åå·²"ä»Šæ—¶ä¸åŒå¾€æ—¥"â€”â€”ä¸‰ä¸ªå‚æ•°å…¨éƒ¨åŒ…å«æœ‰GVKä¿¡æ¯ã€‚
å¯æ˜¯ä¸ºä»€ä¹ˆåœ¨è§£ç è¿‡ç¨‹ä¸­ä¸å†æœ‰"ç‰ˆæœ¬è½¬åŒ–"æ­¥éª¤äº†å‘¢ï¼Ÿéš¾é“è¿™æ¬¡é‡æ„èˆå¼ƒäº†Kubernetesçš„"ç‰ˆæœ¬è½¬åŒ–"å—ï¼Ÿ

å…¶å®ä¸ç„¶ï¼ŒPRä½œè€…å…¶å®æœ‰æ„è€Œä¸ºä¹‹â€”â€”JSON/YAMLåºåˆ—åŒ–å™¨ä»…ç”¨äº**çº¯ç²¹**çš„åºåˆ—åŒ–/ååºåˆ—åŒ–ä»»åŠ¡ã€‚
çœŸæ­£å¸¦æœ‰ç‰ˆæœ¬è½¬åŒ–çš„åºåˆ—åŒ–å™¨å®ç°æ˜¯`codec`ï¼Œå®ƒæ‰€å®ç°çš„ä¹Ÿæ˜¯`Codec`æ¥å£ã€‚
```go title="pkg/runtime/serializer/versioning/versioning.go"

type codec struct {
	serializer runtime.Serializer
	convertor  runtime.ObjectConvertor
	creater    runtime.ObjectCreater
	typer      runtime.Typer

	encodeVersion map[string]unversioned.GroupVersion
    decodeVersion map[string]unversioned.GroupVersion
}
```
å…¶ä¸­ï¼š
* `serializer`æˆå‘˜ä¼šæ˜¯JSON/YAMLåºåˆ—åŒ–å™¨çš„ä¸€ç§ï¼Œå®ƒè´Ÿè´£çº¯ç²¹çš„åºåˆ—åŒ–/ååºåˆ—åŒ–æ­¥éª¤ï¼›
* `convertor`æˆå‘˜ç”¨äº"ç‰ˆæœ¬è½¬åŒ–"æ­¥éª¤ï¼Œè¿™ä¸ªæˆå‘˜å¯ä»¥è®¤ä¸ºæ˜¯å‰¥ç¦»è‡ª"è¿‘ä»£"æ—¶æœŸçš„`Scheme`ä¸­çš„`convertor`ï¼›
* `creater`æˆå‘˜ç”¨äºæ ¹æ®ç»™å®šçš„GVKä¸‰å…ƒç»„åˆ›å»ºå¯¹åº”*kind*ï¼ˆAPIå¯¹è±¡ï¼‰çš„ç©ºå®ä¾‹ï¼ˆ"è½½ä½“"ï¼‰ï¼›
* `typer`æˆå‘˜ç”¨äºåˆ¤å®šä¸€ä¸ªç»™å®šçš„*kind*ï¼ˆAPIå¯¹è±¡ï¼‰æ˜¯å¦æ³¨å†Œè¿‡ï¼›
* `encodeVersion`å’Œ`decodeVersion`æˆå‘˜æ˜¯`codec`åºåˆ—åŒ–å™¨åŒºåˆ«äº"ç°ä»£"ï¼ˆ`Scheme`å¤§ä¸€ç»Ÿï¼‰æ—¶æœŸçš„ç¼–/è§£ç é€»è¾‘çš„å¦ä¸€ä¸ªç‰¹æ€§â€”â€”`codec`æ”¯æŒå°†ç‰ˆæœ¬è½¬åŒ–ä¸ºè°ƒç”¨è€…æŒ‡å®šçš„**ç›®æ ‡ç‰ˆæœ¬**ï¼Œè€Œä¸æ˜¯ä»…é»˜è®¤è½¬åŒ–ä¸ºå†…éƒ¨ç‰ˆæœ¬ã€‚

:::tip
ä¸JSONåºåˆ—åŒ–å™¨ä¸€æ ·ï¼Œ`codec`ç±»å‹åˆå§‹åŒ–`typer`å’Œ`creater`æˆå‘˜æ—¶ç”¨çš„æ˜¯`Scheme`ç±»å‹çš„å®ä¾‹ã€‚
:::

æ‰€ä»¥ï¼Œ`codec`åºåˆ—åŒ–å™¨æ˜¯å¯¹JSON/YAMLåºåˆ—åŒ–å™¨çš„è¿›ä¸€æ­¥å°è£…ã€‚æ¥ä¸‹æ¥æˆ‘ä»¬æ¥çœ‹çœ‹`codec`çš„è§£ç æ–¹æ³•çš„å…·ä½“æ­¥éª¤ï¼š
:::tip æ³¨
ä¸ºäº†å‡è½»è¯»è€…çš„è´Ÿæ‹…ä¹Ÿä¾¿äºè¯»è€…ç†è§£ï¼ŒåŒæ—¶ä¹Ÿä¸ºäº†èšç„¦`codec`è§£ç é€»è¾‘çš„ä¸»å¹²æ­¥éª¤ï¼Œä¸‹é¢çš„ä»£ç çœç•¥äº†ä¸€äº›ç»†èŠ‚ã€‚
:::

```go
// Decode attempts a decode of the object, then tries to convert it to the internal version. If into is provided and the decoding is
// successful, the returned runtime.Object will be the value passed as into. Note that this may bypass conversion if you pass an
// into that matches the serialized version.
func (c *codec) Decode(data []byte, defaultGVK *unversioned.GroupVersionKind, into runtime.Object) (runtime.Object, *unversioned.GroupVersionKind, error) {
    // ...

	obj, gvk, err := c.serializer.Decode(data, defaultGVK, into)
	if err != nil {
		return nil, gvk, err
	}

	// if we specify a target, use generic conversion.
	if into != nil {
		if into == obj {
			// ...
			return into, gvk, nil
		}
		if err := c.convertor.Convert(obj, into); err != nil {
			return nil, gvk, err
		}
		// ...
		return into, gvk, nil
	}

	// invoke a version conversion
	group := gvk.Group
	if defaultGVK != nil {
		group = defaultGVK.Group
	}
	var targetGV unversioned.GroupVersion
	if c.decodeVersion == nil {
		// convert to internal by default
		targetGV.Group = group
		targetGV.Version = runtime.APIVersionInternal
	} else {
		gv, ok := c.decodeVersion[group]
		if !ok {
			// ...
			return obj, gvk, nil
		}
		targetGV = gv
	}

	if gvk.GroupVersion() == targetGV {
		// ...
		return obj, gvk, nil
	}
	// ...

	// Convert if needed.
	out, err := c.convertor.ConvertToVersion(obj, targetGV.String())
	if err != nil {
		return nil, gvk, err
	}
	// ...
	return out, gvk, nil
}

```

1. åˆ©ç”¨åŸºç¡€çš„JSON/YAMLåºåˆ—åŒ–ç»„ä»¶è¿›è¡Œçº¯ç²¹çš„ååºåˆ—åŒ–æ­¥éª¤ã€‚
2. ç‰ˆæœ¬è½¬åŒ–

   * å¦‚æœè°ƒç”¨è¿™æä¾›äº†ç›®æ ‡APIå¯¹è±¡è½½ä½“`into`ï¼Œåˆ™å°†ä¸Šä¸€æ­¥ååºåˆ—åŒ–ç»“æœè½¬åŒ–ä¸ºè°ƒç”¨è€…æä¾›çš„`into`å¯¹è±¡ï¼›
   * å¦‚æœè°ƒç”¨è€…æ²¡æœ‰æä¾›ç›®æ ‡APIå¯¹è±¡è½½ä½“ï¼ˆ`into`ä¸º`nil`ï¼‰ï¼Œå¹¶ä¸”äº‹å…ˆæä¾›äº†ç›®æ ‡ç‰ˆæœ¬çš„GVä¿¡æ¯ï¼ˆ`decodeVersion`ï¼‰åˆ™è½¬åŒ–ä¸ºæŒ‡å®šçš„ç›®æ ‡ç‰ˆæœ¬ï¼›
   * å¦‚æœè°ƒç”¨è€…å³æ²¡æœ‰æä¾›ç›®æ ‡APIå¯¹è±¡è½½ä½“ï¼ˆ`into`ä¸º`nil`ï¼‰ï¼Œä¹Ÿæ²¡æœ‰æä¾›ç›®æ ‡ç‰ˆæœ¬çš„GVä¿¡æ¯ï¼ˆ`decodeVersion`æˆå‘˜ä¸º`nil`ï¼‰åˆ™å°†ä¸Šä¸€æ­¥ååºåˆ—åŒ–çš„ç»“æœé»˜è®¤è½¬åŒ–ä¸ºå†…éƒ¨ç‰ˆæœ¬ã€‚


### åºåˆ—åŒ–å™¨å·¥å‚CodecFactory

æˆ‘ä»¬ç°åœ¨å·²ç»çŸ¥é“`codec`åºåˆ—åŒ–å™¨æä¾›äº†è®¸å¤šå¯å®šåˆ¶åŒ–é¡¹ã€‚ä¾‹å¦‚å¯ä»¥é…ç½®JSONæˆ–è€…YAMLä½œä¸ºåº•å±‚çš„åºåˆ—åŒ–/ååºåˆ—åŒ–ç»„ä»¶ï¼Œä¹Ÿå¯ä»¥äº‹å…ˆé…ç½®å¥½æ‰€è¦è½¬åŒ–çš„ç›®æ ‡ç‰ˆæœ¬ä¿¡æ¯ã€‚
å› æ­¤ï¼Œåœ¨è¯¥PRä¸­ï¼Œä½œè€…ä¹ŸåŒæ—¶æä¾›äº†`CodecFactory`ï¼ˆ*åºåˆ—åŒ–å™¨å·¥å‚*ï¼‰â€”â€”ç”¨äº"ç”Ÿäº§"ä¸åŒå®šåˆ¶åŒ–çš„`codec`ã€‚
```go
// CodecFactory provides methods for retrieving codecs and serializers for specific
// versions and content types.
type CodecFactory struct {
	scheme      *runtime.Scheme
    universal   runtime.Decoder
	serializers []serializerType
	accepts     []string


	// ...
}
```

å…¶ä¸­ï¼š
* `scheme`æˆå‘˜ç”¨äº"APIå¯¹è±¡æ³¨å†Œ"ï¼›
* `serializers`æˆå‘˜ç”¨äºå­˜æ”¾åŒ…æ‹¬JSONå’ŒYAMLä¸¤ç§æ ¼å¼çš„åŸºç¡€åºåˆ—åŒ–å™¨ï¼›
* `accepts`æˆå‘˜ç”¨äºå­˜æ”¾**æ”¯æŒ**çš„ç¼–/è§£ç æ ¼å¼ä¿¡æ¯ï¼ŒåŒ…æ‹¬ï¼š`"application/json"`ä»¥åŠ`"application/yaml"`;
* `universal`æˆå‘˜æ„åœ¨æä¾›ä¸€ä¸ª**é€šç”¨**å¿«æ·çš„è§£ç å™¨ï¼Œå®ƒèƒ½å¤Ÿè¯†åˆ«å­—èŠ‚åºåˆ—çš„æ•°æ®æ ¼å¼ï¼ˆJSON/YAMLï¼‰å†æ‰¾åˆ°å¯¹åº”çš„åŸºç¡€çš„åºåˆ—åŒ–å™¨è¿›è¡Œååºåˆ—åŒ–ã€‚


å¦å¤–ï¼Œ`CodecFactory`å…¶å®å®ç°äº†`NegotiatedSerializer`ï¼ˆ*åå•†åºåˆ—åŒ–å™¨*æ¥å£ï¼‰:
```go
var _ runtime.NegotiatedSerializer = &CodecFactory{}

// SupportedMediaTypes returns the RFC2046 media types that this factory has serializers for.
func (f CodecFactory) SupportedMediaTypes() []string {
	return f.accepts
}

// SerializerForMediaType returns a serializer that matches the provided RFC2046 mediaType, or false if no such
// serializer exists
func (f CodecFactory) SerializerForMediaType(mediaType string, options map[string]string) (runtime.Serializer, bool) {
	for _, s := range f.serializers {
		for _, accepted := range s.AcceptContentTypes {
			if accepted == mediaType {
				if v, ok := options["pretty"]; ok && v == "1" && s.PrettySerializer != nil {
					return s.PrettySerializer, true
				}
				return s.Serializer, true
			}
		}
	}
	return nil, false
}

// DecoderToVersion returns a decoder that targets the provided group version.
func (f CodecFactory) DecoderToVersion(serializer runtime.Serializer, gv unversioned.GroupVersion) runtime.Decoder {
	return f.CodecForVersions(serializer, nil, []unversioned.GroupVersion{gv})
}

// EncoderForVersion returns an encoder that targets the provided group version.
func (f CodecFactory) EncoderForVersion(serializer runtime.Serializer, gv unversioned.GroupVersion) runtime.Encoder {
	return f.CodecForVersions(serializer, []unversioned.GroupVersion{gv}, nil)
}
```
å®ƒå®ç°çš„`NegotiatedSerializer`æ¥å£çš„æ–¹æ³•ï¼š
* `SupportedMediaTypes()`æ–¹æ³•ç”¨äºè¿”å›æ‰€æ”¯æŒçš„ç¼–ç æ ¼å¼ï¼›
* `SerializerForMediaType()`æ–¹æ³•ç”¨äº"ç”Ÿäº§"ä¸€ä¸ªæŒ‡å®šç¼–ç ç±»å‹çš„"å®šåˆ¶åŒ–"`codec`;
* `EncoderForVersion()/DecoderToVersion()`æ–¹æ³•ç”¨äº"ç”Ÿäº§"ä¸€ä¸ªå¯ä»¥è½¬åŒ–ä¸ºæŒ‡å®šç›®æ ‡ç‰ˆæœ¬çš„"å®šåˆ¶åŒ–"`codec`ï¼›


#### åˆ›å»ºCodecFactoryå¯¹è±¡

ä»‹ç»å®Œ`CodecFactory`ç±»å‹åï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬å†æ¥çœ‹çœ‹å¦‚ä½•åˆ›å»ºä¸€ä¸ª`CodecFactory`ç±»ï¼š
```go
func NewCodecFactory(scheme *runtime.Scheme) CodecFactory {
	// ...
}
```
å¼€å‘è€…ä¸ºæˆ‘ä»¬å°è£…çš„åˆå§‹åŒ–å‡½æ•°ååˆ†ç®€å•â€”â€”è°ƒç”¨è€…ä»…éœ€è¦æä¾›ä¸€ä¸ª`Scheme`å¯¹è±¡å³å¯ï¼Œå‰©ä¸‹çš„ç”±åˆå§‹åŒ–å‡½æ•°å®Œæˆã€‚[ğŸˆ](../intro#çº¦å®š)

ä¸ºäº†å‡è½»è¯»è€…è´Ÿæ‹…ï¼Œåœ¨è¿™é‡Œæˆ‘ä»¬ä¸å†å…³æ³¨åˆå§‹åŒ–çš„ç»†èŠ‚ã€‚


#### WithoutConversion


æˆ‘ä»¬çŸ¥é“"ç‰ˆæœ¬è½¬åŒ–"åœ¨`kube-apiserver`æ˜¯ä¸ªååˆ†é‡è¦çš„è¡Œä¸ºã€‚ä½†æ˜¯å¯¹äºå®¢æˆ·ç«¯ï¼ˆ`client-go`ï¼‰æ¥è¯´ï¼Œå®ƒä»¬åœ¨åºåˆ—åŒ–/ååºåˆ—åŒ–èµ„æºæ—¶å…¶å®å¹¶ä¸éœ€è¦"ç‰ˆæœ¬è½¬åŒ–"ã€‚
é’ˆå¯¹è¿™ç§éœ€æ±‚ï¼Œåœ¨[Kubernetes v1.15.0-alpha1](https://github.com/kubernetes/kubernetes/tree/v1.15.0-alpha1)
[<GithubSVG /> Pull Request #76098](https://github.com/kubernetes/kubernetes/pull/76098)
å¼€å‘è€…ç»™`CodecFactory`å°è£…äº†ä¸€ä¸ª"å¿«æ·"æ–¹æ³•`WithoutConversion()`ï¼š
```go
// WithoutConversion returns a NegotiatedSerializer that performs no conversion
func (f CodecFactory) WithoutConversion() runtime.NegotiatedSerializer {
	// ...
}
```
ç”¨äºè¿”å›ä¸€ä¸ªåœ¨ç¼–/è§£ç æ—¶**ä¸è¿›è¡Œç‰ˆæœ¬è½¬åŒ–**çš„`CodecFactory`ã€‚[ğŸˆ](../intro#çº¦å®š)

### URLå‚æ•°ç¼–è§£ç å™¨ParameterCodec

ä¸Šè¿°çš„`CodecFactory`ä¸»è¦ç”¨äºHTTP**è¯·æ±‚/è¿”å›ä½“**ï¼ˆå³*èµ„æº*ï¼‰çš„ç¼–è§£/ç ã€‚

åœ¨ææ¡ˆ[<GithubSVG /> Issue #7111](https://github.com/kubernetes/kubernetes/issues/7111)ä¸­ï¼Œä½œè€…ç”šè‡³"è´´å¿ƒåœ°"æè®®ä¸ºHTTP URLå‚æ•°ï¼ˆQuery Parametersï¼‰ä¸Goå¯¹è±¡ä¹‹é—´çš„è½¬æ¢ä¹Ÿä¸“é—¨å°è£…æˆä¸€ç§"ç¼–è§£ç å™¨"[^2]ï¼š
> There are places where we want to convert map[string]interface{} (generic JSON object representation) or a map[string][]string (url.Values) into a versioned Go struct, which is dependent on a type of marshaling (i.e. following JSON rules, or Query parameter rules).

åœ¨[<GithubSVG /> Pull Request #17922](https://github.com/kubernetes/kubernetes/pull/17922)ä¸­ï¼Œä½œè€…å®ç°äº†`ParameterCodec`ç¼–è§£ç å™¨ä¸“é—¨ç”¨äºæ­¤ç›®çš„ï¼š
```go
// parameterCodec implements conversion to and from query parameters and objects.
type parameterCodec struct {
	typer     Typer
	convertor ObjectConvertor
	creator   ObjectCreater
}
```


ä¾‹å¦‚ï¼Œé€šå¸¸æˆ‘ä»¬å¯ä»¥ä½¿ç”¨`apimachinery`åº“æä¾›çš„`metav1.ListOptions`ç»“æ„[^3]æ¥åŸºäºæ¡ä»¶åœ°æŸ¥è¯¢èµ„æºé›†åˆï¼š
```go
listOptions := metav1.ListOptions{
        Limit: 1,
        LabelSelector: "app=foo",
    }
pods, _ := clientset.CoreV1().Pods("default").List(listOptions)
```
`client-go`å…¶å®åœ¨èƒŒåæ­£æ˜¯åˆ©ç”¨äº†`ParameterCodec`"ç¼–è§£ç å™¨"å°†`metav1.ListOptions`ç±»å‹æœ€ç»ˆ"è§£ç "æˆHTTP URLå‚æ•°`limit=1&app=foo`ã€‚
å¦å¤–ï¼Œéœ€è¦æåŠçš„æ˜¯ï¼Œ`ParameterCodec`"ç¼–è§£ç å™¨"ä»ç„¶åŸºäº`Scheme`æ³¨å†Œæœºåˆ¶å·¥ä½œï¼ˆ`typer`å’Œ`creator`æˆå‘˜ï¼‰ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œ`metav1.ListOptions`ç±»å‹ä¹ŸåŒæ ·éœ€è¦æ³¨å†Œè¿›`scheme`ä¸­ã€‚

### å°ç»“

:::tip å°ç»“
åœ¨æœ¬å°èŠ‚ä¸­ï¼Œæˆ‘ä»¬é¦–å…ˆå¼ºè°ƒäº†åœ¨Kubernetesä¸Šä¸‹æ–‡ä¸­ç¼–/è§£ç çš„ç‰¹æ®Šæ€§ï¼Œè€Œè¿™ç§ç‰¹æ®Šæ€§æœ¬è´¨ä¸Šæ¥è‡ªäºèµ„æºçš„å¤šç‰ˆæœ¬ä»¥åŠç‰ˆæœ¬é—´çš„ç›¸äº’è½¬åŒ–ã€‚
ä¹‹åæˆ‘ä»¬æ€»ç»“äº†Kubernetesç¼–/è§£ç ä½“ç³»æ¼”åŒ–çš„å››ä¸ªé‡è¦é˜¶æ®µã€‚
å¦‚ä»Šçš„Kubernetesä½“ç³»ä¸»è¦åŸºäºä¸¤ä¸ªç»„ä»¶ï¼š
* `Scheme`â€”â€”*kind*æ³¨å†Œ
* `codec`â€”â€”åºåˆ—åŒ–/ååºåˆ—åŒ–åŠèµ„æºç‰ˆæœ¬è½¬åŒ–

å¦å¤–ï¼Œæˆ‘ä»¬è¿˜ä»‹ç»äº†`CodecFactory`ï¼Œå®ƒå®ç°äº†`NegotiatedSerializer`ï¼ˆ*åå•†åºåˆ—åŒ–å™¨*ï¼‰ï¼Œæ”¯æŒå¤šç§ç¼–ç æ ¼å¼ï¼Œä¹Ÿå¯ä»¥ç”¨äºç”Ÿäº§"å®šåˆ¶åŒ–"çš„`codec`ã€‚

åŒæ—¶æˆ‘ä»¬ä¹ŸæŒ‡å‡ºäº†å¯¹äºå®¢æˆ·ç«¯æ¥è¯´ï¼Œå®ƒåœ¨åºåˆ—åŒ–/ååºåˆ—åŒ–èµ„æºæ—¶å¹¶ä¸éœ€è¦åƒKubernetes API Serverä¸€æ ·è¿›è¡Œç‰ˆæœ¬è½¬ã€‚é’ˆå¯¹è¿™ç§éœ€æ±‚ï¼Œ`CodecFactory`çš„`WithoutConversion()`æ–¹æ³•ä¹Ÿå¯¹æ­¤æä¾›äº†æ–¹ä¾¿å¿«æ·çš„æ”¯æŒã€‚
:::


[^1]: å½¼æ—¶*èµ„æº*çš„æ¦‚å¿µç”šè‡³è¿˜æ²¡æœ‰æ­£å¼å½¢æˆã€‚åœ¨Kubernetesæ—©æœŸé˜¶æ®µï¼Œå®˜æ–¹å¼€å‘è€…æ›´å€¾å‘äºä½¿ç”¨æœ¯è¯­*APIå¯¹è±¡ï¼ˆAPI Objectï¼‰*æˆ–æ˜¯*APIç±»å‹ï¼ˆAPI Typeï¼‰*æ¥æŒ‡ä»£APIçš„JSON Schemaã€‚*APIå¯¹è±¡ï¼ˆAPI Objectï¼‰*é¦–æ¬¡å‡ºç°åœ¨[<GithubSVG /> Pull Request #529](https://github.com/kubernetes/kubernetes/pull/529)ã€‚
[^2]: é€šå¸¸æˆ‘ä»¬æ‰€è¯´çš„*åºåˆ—åŒ–å™¨*æˆ–è€…*ç¼–è§£ç å™¨*æ˜¯æŒ‡å­—èŠ‚åºåˆ—ï¼ˆ`[]bytes`ï¼‰ä¸Goå¯¹è±¡ä¹‹é—´çš„è½¬åŒ–ï¼Œæ­¤å¤„çš„"ç¼–è§£ç å™¨"å¹¶ä¸èƒ½å½’ä¸ºæ­¤ç±»ï¼Œå®ƒçš„ä½œç”¨æ˜¯HTTP URLå‚æ•°ï¼ˆQuery Parametersï¼‰ä¸Goå¯¹è±¡ä¹‹é—´çš„è½¬æ¢ã€‚
[^3]: æ³¨æ„æ­¤å¤„çš„`ListOptions`ä¸æˆ‘ä»¬åœ¨ä¹‹å‰[å†è¯†kind](./gvk#å†è¯†kind)å°èŠ‚ä¸­æåŠçš„`DeleteOptions`çš„åŒºåˆ«ï¼š`DeleteOptions`ä¸`ListOptions`è™½ç„¶åŒå±äº*kind*ç¬¬ä¸‰ç§ç±»ï¼Œä½†æ˜¯`DeleteOptions`å¯¹åº”çš„æ˜¯HTTP**è¯·æ±‚ä½“**è€Œä¸æ˜¯HTTP URLå‚æ•°ã€‚

      

