---
sidebar_position: 2
---
import GithubSVG from '@site/static/img/github-mark.svg';
import KubernetesSVG from '@site/static/img/kubernetes-mark.svg';
import WatchRequestSVG from '@site/static/img/watch-request.svg';
import StreamWatcherSVG from '@site/static/img/streamwatcher.svg';


# Controller
åœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†æ­£å¼ä»‹ç»åœ¨Kubernetesè¯­å¢ƒä¸‹ï¼Œ*æ§åˆ¶å™¨ï¼ˆControllerï¼‰*ç©¶ç«ŸæŒ‡çš„æ˜¯ä»€ä¹ˆã€‚
åœ¨æ­£å¼ä»‹ç»*Controller*æ¦‚å¿µä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦é“ºå«ä¸€äº›è¾…åŠ©æ¦‚å¿µã€‚

## å¯¹è±¡çš„çŠ¶æ€ä¸åè°ƒ

æ—©åœ¨[Kuberneteså¯¹è±¡](../apimachinery/kubernetes-api#kuberneteså¯¹è±¡kubernetes-object)å°èŠ‚ï¼Œæˆ‘ä»¬å°±å·²ç»ä»‹ç»äº†Kubernetesæ˜¯ä¸€ä¸ªä»¥Kubernetes APIä¸ºä¸­å¿ƒçš„*å£°æ˜å¼èµ„æºç®¡ç†ç³»ç»Ÿ*ã€‚
ç”¨æˆ·å‘Kubernetesæè¿°èµ„æºçš„æœŸæœ›çŠ¶æ€ï¼Œç”±Kubernetesç³»ç»Ÿæ§åˆ¶ä»¥ä½¿èµ„æºè¾¾åˆ°æœŸæœ›çŠ¶æ€ã€‚
åœ¨Kubernetesä¸­ï¼Œä½¿Kuberneteså¯¹è±¡çš„æœŸæœ›çŠ¶æ€ä¸å®é™…çŠ¶æ€ä¿æŒä¸€è‡´çš„è¿‡ç¨‹è¢«ç§°ä¸º*åè°ƒï¼ˆreconcileï¼‰*ã€‚


## æ§åˆ¶å™¨ï¼ˆControllerï¼‰

åœ¨Kubernetesä¸­ï¼Œ*æ§åˆ¶å™¨ï¼ˆControllerï¼‰*æ˜¯æŒ‡ç”¨äº*åè°ƒ*çš„æ— é™å¾ªç¯[^2][^3]ã€‚

å½“ç„¶ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥ä»Kubernetesä½œä¸ºä¸€ä¸ª*å£°æ˜å¼ç³»ç»Ÿ*çš„è§’åº¦æ¥è§£é‡Š*æ§åˆ¶å™¨*ã€‚
åœ¨å£°æ˜å¼ç³»ç»Ÿä¸­ï¼Œç”¨æˆ·çŸ¥é“ç³»ç»Ÿçš„æœŸæœ›çŠ¶æ€ï¼Œç”¨æˆ·ä»…å‘ç³»ç»Ÿæä¾›æœŸæœ›çŠ¶æ€çš„æè¿°ï¼Œç”±ç³»ç»Ÿæ¥ç¡®å®šä»å½“å‰çŠ¶æ€è¾¾åˆ°æœŸæœ›çŠ¶æ€æ‰€éœ€è¦çš„åŠ¨ä½œåºåˆ—ã€‚
è€Œç³»ç»Ÿä¸­å†³å®šå¹¶æ‰§è¡ŒåŠ¨ä½œåºåˆ—çš„ç»„ä»¶è¢«ç§°ä¸º*æ§åˆ¶å™¨*ã€‚

å¦å¤–ï¼ŒKubernetesè®¾è®¡æ–‡æ¡£[The Kubernetes Resource Model (KRM) <GithubSVG />](https://github.com/kubernetes/design-proposals-archive/blob/main/architecture/resource-management.md#declarative-control)ä¹Ÿå¯¹*Controller*çš„è¡Œä¸ºåšäº†è§„èŒƒï¼š
>
> The intent is carried out by asynchronous controllers, which interact through the Kubernetes API.
> Controllers donâ€™t access the state store, etcd, directly, and donâ€™t communicate via private direct APIs.
>
> ...
>
> Controllers continuously strive to make the observed state match the desired state, and report back their status to the apiserver asynchronously.


æ„æ€æ˜¯è¯´æ§åˆ¶å™¨**åªèƒ½**é€šè¿‡ä¸Kubernetes APIäº¤äº’æ¥å®æ–½åè°ƒåŠ¨ä½œï¼Œè€Œä¸èƒ½ç›´æ¥è®¿é—®çŠ¶æ€é›†ç¾¤çš„å­˜å‚¨ï¼ˆetcdï¼‰æˆ–è€…å…¶ä»–ç§æœ‰çš„æœåŠ¡[^5]ã€‚

æ§åˆ¶å™¨åœ¨Kubernetes**å£°æ˜å¼èµ„æºç®¡ç†ç³»ç»Ÿ**

Kubernetesé›†ç¾¤å†…ç½®äº†ä¸€äº›åŸç”Ÿèµ„æºçš„æ§åˆ¶å™¨ï¼Œä¾‹å¦‚Jobæ§åˆ¶å™¨ç­‰ã€‚
å½“ç”¨æˆ·å£°æ˜ä¸€ä¸ª`job`èµ„æºåï¼ŒJobæ§åˆ¶å™¨æœ¬èº«å¹¶ä¸åˆ›å»ºpodèµ„æºæ¥æ‰§è¡Œä»»åŠ¡ï¼Œå®ƒè€Œæ˜¯é€šè¿‡Kubernetes APIæ¥åˆ›å»ºpodèµ„æºæ¥è¿è¡Œä»»åŠ¡[^4]ï¼Œå¹¶åŒæ—¶ä¸æ–­å°†`job`å¯¹è±¡çš„çŠ¶æ€"æ±‡æŠ¥"ç»™Kubernetes APIä»¥å†™å…¥`etcd`ä¸­ã€‚
å¯è§ï¼ŒJobæ§åˆ¶å™¨çš„æ‰€æœ‰è¡Œä¸ºéƒ½åªä¸Kubernetesäº¤äº’ã€‚


:::tip
ç”±äºèµ„æº*æ§åˆ¶å™¨*åªèƒ½ä¸Kubernetes APIäº¤äº’ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥è®¤ä¸º*æ§åˆ¶å™¨*æ˜¯ä¸€ç§å…·æœ‰ç‰¹æ®Šè¡Œä¸ºçš„èµ„æºå®¢æˆ·ç«¯ã€‚
:::

## æ§åˆ¶å™¨ä¸å­èµ„æºstatus
åœ¨ä¹‹å‰[å­èµ„æºï¼ˆsubresourceï¼‰](../apimachinery/kubernetes-api#å­èµ„æºsubresource)å°èŠ‚ä¸­ï¼Œæˆ‘ä»¬å¼•å…¥äº†*å­èµ„æº*çš„æ¦‚å¿µã€‚
æˆ‘ä»¬å·²ç»çŸ¥é“å¼•å…¥`status`å­èµ„æºçš„åŠ¨æœºæ˜¯ä¸ºäº†å°†å¯¹Kuberneteså¯¹è±¡`status`å­—æ®µï¼ˆå®é™…çŠ¶æ€ï¼‰çš„å˜æ›´ä¸`spec`å­—æ®µï¼ˆæœŸæœ›çŠ¶æ€ï¼‰çš„å˜æ›´åˆ†å¼€ã€‚
ä½†å½“æ—¶ç”±äºç¼ºä¹Kubernetes*æ§åˆ¶å™¨*çš„æ¦‚å¿µï¼Œæˆ‘ä»¬ä»å¹¶å‘æ§åˆ¶çš„è§’åº¦å»è§£é‡Šåˆ†å¼€çš„åŸç”±ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å¯ä»¥è¡¥å……æ›´å¤šçš„èƒŒæ™¯ã€‚Kubernetesä½œä¸ºä¸€ä¸ª*å£°æ˜å¼èµ„æºç®¡ç†ç³»ç»Ÿ*ï¼š
* ç”¨æˆ·å¯ä»¥å†™å…¥ï¼ˆæˆ–æ›´æ”¹ï¼‰èµ„æºçš„`spec`ï¼ˆæœŸæœ›çŠ¶æ€ï¼‰ï¼Œä½†ä¸åº”æ›´æ”¹èµ„æºçš„`status`å­—æ®µï¼›
* *æ§åˆ¶å™¨*å¯ä»¥å†™å…¥ï¼ˆæˆ–æ›´æ”¹ï¼‰`status`å­—æ®µï¼ˆå®é™…çŠ¶æ€ï¼‰ï¼Œä½†ä¸åº”æ›´æ”¹èµ„æºçš„`spec`å­—æ®µã€‚

é€šè¿‡èµ„æºAPIåˆ›å»ºæˆ–è€…æ›´æ”¹èµ„æºæ—¶ï¼Œ`kube-apiserver`ä¼šè‡ªåŠ¨å¿½ç•¥è¯·æ±‚ä½“ä¸­`status`å­—æ®µä¸­çš„å†…å®¹ï¼›è€Œé€šè¿‡å­èµ„æº`status`APIæ›´æ–°èµ„æºçŠ¶æ€æ—¶ï¼Œ`kube-apiserver`ä¹Ÿä¼šå¿½ç•¥è¯·æ±‚ä½“ä¸­`status`å­—æ®µä¹‹å¤–çš„æ›´æ”¹ã€‚



### ä½¿ç”¨RESTClientæ›´æ–°Kuberneteså¯¹è±¡çŠ¶æ€

æˆ‘ä»¬ç°åœ¨å·²ç»çŸ¥é“*æ§åˆ¶å™¨*æ˜¯ä¸€ç§å…·æœ‰ç‰¹æ®Šè¡Œä¸ºçš„Kuberneteså®¢æˆ·ç«¯ï¼Œå®ƒéœ€è¦é€šè¿‡Kuberneteså­èµ„æºAPI`status`"æ±‡æŠ¥"Kuberneteså¯¹è±¡çš„å½“å‰çŠ¶æ€ã€‚å¹¸è¿çš„æ˜¯ï¼Œ`client-go`ä½œä¸ºKubernetesæ ‡å‡†å®¢æˆ·ç«¯åº“å·²ç»ä¸ºæˆ‘ä»¬å°è£…äº†ç›¸å…³æ–¹æ³•ç”¨äºä¸å­èµ„æºAPIäº¤äº’ã€‚


æˆ‘ä»¬å…ˆä»`client-go`å°è£…çš„[èµ„æºå®¢æˆ·ç«¯](./restclient#èµ„æºå®¢æˆ·ç«¯)è¯´èµ·ã€‚å¯¹äºé‚£äº›æ˜¯*Kuberneteså¯¹è±¡*çš„èµ„æºç±»å‹ï¼Œ`client-go`çš„åŸç”Ÿ*èµ„æºå®¢æˆ·ç«¯*ä¸“é—¨å°è£…äº†ä¸€ä¸ª`UpdateStatus()`çš„æ–¹æ³•ç”¨äºæ›´æ–°å¯¹è±¡çš„å½“å‰çŠ¶æ€ã€‚
ä¾‹å¦‚ï¼Œæˆ‘ä»¬ä»¥`Pod`å®¢æˆ·ç«¯ä¸ºä¾‹ï¼š
```go "k8s.io/client-go/kubernetes/typed/core/v1/pod.go"
type PodInterface interface {
	Create(ctx context.Context, pod *v1.Pod, opts metav1.CreateOptions) (*v1.Pod, error)
	Update(ctx context.Context, pod *v1.Pod, opts metav1.UpdateOptions) (*v1.Pod, error)
	// highlight-next-line
	UpdateStatus(ctx context.Context, pod *v1.Pod, opts metav1.UpdateOptions) (*v1.Pod, error)
	Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error
	Get(ctx context.Context, name string, opts metav1.GetOptions) (*v1.Pod, error)
	List(ctx context.Context, opts metav1.ListOptions) (*v1.PodList, error)
	Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error)
	Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts metav1.PatchOptions, subresources ...string) (result *v1.Pod, err error)
	// ...
}
```
æˆ‘ä»¬åœ¨[èµ„æºå®¢æˆ·ç«¯](./restclient#èµ„æºå®¢æˆ·ç«¯)å°èŠ‚ä¸­å·²ç»è¯´æ˜äº†*èµ„æºå®¢æˆ·ç«¯*ä½¿ç”¨çš„æ˜¯`RESTClient`ç»„ä»¶ã€‚æˆ‘ä»¬ä»¥`pods`èµ„æºå®¢æˆ·ç«¯`UpdateStatus()`æ–¹æ³•çš„å®ç°ä¸ºä¾‹ï¼š
```go
func (c *pods) UpdateStatus(ctx context.Context, pod *v1.Pod, opts metav1.UpdateOptions) (result *v1.Pod, err error) {
	result = &v1.Pod{}
	err = c.client.Put().
		Namespace(c.ns).
		Resource("pods").
		Name(pod.Name).
		// highlight-next-line
		SubResource("status").
		VersionedParams(&opts, scheme.ParameterCodec).
		Body(pod).
		Do(ctx).
		Into(result)
	return
}
```

ä»å®ç°æ¥çœ‹ï¼Œ[`Request`ç±»å‹](./restclient#requestç±»å‹)å·²ç»ä¸ºæˆ‘ä»¬å°è£…äº†`SubResource()`æ–¹æ³•ï¼Œä½¿ç”¨æ–¹å¼ä¹Ÿååˆ†ç®€å•ï¼Œåªè¦å¡«å…¥ç›¸åº”çš„*å­èµ„æº*åç§°å°±èƒ½ä¸ç›¸åº”çš„å­èµ„æºAPIäº¤äº’ã€‚
åœ¨æœ¬ä¾‹ä¸­ï¼Œç”±äºè¦é€šè¿‡å­èµ„æº`status`æ›´æ–°å¯¹è±¡çš„å½“å‰çŠ¶æ€ï¼Œåªè¦åœ¨å‚æ•°ä¸­å¡«å…¥`"status"`å³å¯ã€‚[ğŸˆ](../intro#çº¦å®š)

:::tip æ³¨
é€šè¿‡æ¢ç©¶åŸç”Ÿ`pods`èµ„æºå®¢æˆ·ç«¯`UpdateStatus()`çš„å®ç°ï¼Œæˆ‘ä»¬å…¶å®å·²ç»å­¦ä¼šäº†å¦‚ä½•ä½¿ç”¨`RESTClient`åŸºç¡€ç»„ä»¶æ›´æ–°å¯¹è±¡çš„å½“å‰çŠ¶æ€â€”â€”æˆ‘ä»¬åœ¨ç¼–å†™*è‡ªå®šä¹‰èµ„æº*å®¢æˆ·ç«¯æ—¶ä¹Ÿéœ€è¦ä½¿ç”¨åŒæ ·çš„æ–¹æ³•ã€‚

:::



      
## æ§åˆ¶å™¨æ¨¡å¼

æ ¹æ®*æ§åˆ¶å™¨*çš„å®šä¹‰ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ä¸€æ®µä¼ªä»£ç æè¿°ä¸€ç§æœ€ä¸ºç®€å•åŸºç¡€çš„æ§åˆ¶å™¨å®ç°ï¼š
```go
for {
  desired := getDesiredState()
  current := getCurrentState()
  makeChanges(desired, current)
}
```
Kuberneteså„ç§æ§åˆ¶å™¨çš„å®ç°æœ¬è´¨ä¸Šéƒ½æ˜¯å¯¹æ­¤åŸºæœ¬æ¡†æ¶çš„ä¼˜åŒ–å’Œæ‰©å±•ã€‚


## è¢«é—å¿˜çš„ç›‘å¬ï¼ˆwatchï¼‰æœºåˆ¶
åœ¨ä¸Šè¿°çš„ç»“æ„ä¸­ï¼Œç›¸æ¯”äºé€šè¿‡è½®è¯¢ä¸æ–­ä¸»åŠ¨è·å–èµ„æºçš„çŠ¶æ€ï¼Œ ä¸€ä¸ªæ˜æ˜¾å¯ä»¥ä¼˜åŒ–çš„åœ°æ–¹æ˜¯æˆ‘ä»¬å¯ä»¥**è¢«åŠ¨åœ°**åªåœ¨**æœ‰å¯¹è±¡çŠ¶æ€å‘ç”Ÿå˜æ›´çš„æ—¶å€™**æ‰è§¦å‘åè°ƒåŠ¨ä½œã€‚
åŸå› ä¹Ÿå¾ˆç®€å•ï¼Œåªæœ‰å½“å¯¹è±¡çŠ¶æ€å‘ç”Ÿå˜æ›´çš„æ—¶å€™ï¼Œæ‰æœ‰å¯èƒ½ä¸æœŸæœ›çš„çŠ¶æ€å‘ç”Ÿåç¦»ï¼Œå› æ­¤æˆ‘ä»¬åªè¦åœ¨æ­¤æ—¶åˆ»è§¦å‘åè°ƒåŠ¨ä½œå³å¯ã€‚

å¹¸è¿çš„æ˜¯ï¼ŒKubernetes APIæ”¯æŒæŒç»­*ç›‘å¬ï¼ˆwatchï¼‰*èµ„æºçš„å˜æ›´ï¼ˆåŒ…æ‹¬*æ–°å¢*ï¼Œ*ä¿®æ”¹*ä»¥åŠ*åˆ é™¤*äº‹ä»¶ï¼‰ã€‚
å…·ä½“æ¥è¯´ï¼Œåœ¨èµ„æºå¯¹åº”çš„APIçš„åŸºç¡€ä¸ŠåŠ ä¸Š`?watch=true`çš„æŸ¥è¯¢å‚æ•°ï¼ˆquery parameterï¼‰å°±å¯ä»¥å¯¹èµ„æºçš„å˜æ›´è¿›è¡Œç›‘å¬ã€‚
ä¾‹å¦‚ï¼š
```bash
GET /api/v1/namespaces/test/pods?watch=true
---
200 OK
Transfer-Encoding: chunked
Content-Type: application/json

{
  "type": "ADDED",
  "object": {"kind": "Pod", "apiVersion": "v1", "metadata": {"resourceVersion": "10596", ...}, ...}
}
{
  "type": "MODIFIED",
  "object": {"kind": "Pod", "apiVersion": "v1", "metadata": {"resourceVersion": "11020", ...}, ...}
}
...
```


è¿™äº›å˜æ›´äº‹ä»¶ä»¥HTTP"æµ"[^5]çš„å½¢å¼è¿”å›ã€‚å¦å¤–ï¼Œä»ä¸Šè¿°ä¾‹å­å¯ä»¥çœ‹å‡ºï¼šæ¯ä¸ªå˜æ›´äº‹ä»¶åŒ…æ‹¬ä¸¤ä¸ªéƒ¨åˆ†ï¼šç±»å‹ï¼ˆ`type`ï¼‰ä»¥åŠèµ„æºæœ¬èº«ï¼ˆ`object`ï¼‰ã€‚

### ä½¿ç”¨RESTClientç›‘å¬èµ„æº
`RESTClient`ä¸­ä¸ºæˆ‘ä»¬å°è£…äº†ç›¸å…³çš„æ–¹æ³•ç”¨äºå¯¹èµ„æºç±»å‹çš„ç›‘å¬ã€‚æˆ‘ä»¬å…ˆæ¥çœ‹çœ‹å¦‚ä½•ä½¿ç”¨`RESTClient`æ¥ç›‘å¬èµ„æºçš„ä¸€ä¸ªä¾‹å­ï¼š
```go
// Assume restClient is initialized.
opts := metav1.ListOptions{}
opts.Watch = true
watcher, _ = restClient.
        Get().
        Namespace("default").
        Resource("pods").
        VersionedParams(&opts, scheme.ParameterCodec).
        Watch()

for event := range watcher.ResultChan() {
    fmt.Printf("Event type: %v\n", event.Type)
    fmt.Printf("Pod name: %v\n", event.Object.(*v1.Pod).Name)
}
```
* é¦–å…ˆæˆ‘ä»¬éœ€è¦å°†`metav1.ListOptions`å¯¹è±¡çš„`Watch`æˆå‘˜è®¾ç½®ä¸º`true`ã€‚`metav1.ListOptions`å¯¹è±¡å°†æœ€ç»ˆä¼šè¢«`scheme.ParameterCodec`ç¼–ç æˆè¯·æ±‚URLä¸­çš„`?watch=true`éƒ¨åˆ†ã€‚
* `Watch()`æ–¹æ³•è¿”å›çš„ä¸€ä¸ªæ˜¯`StreamWatcher`å¯¹è±¡ã€‚`StreamWatcher`å¯¹è±¡ä¸æ–­å°†åŸºäºè¿”å›ä½“ä¸­çš„æ•°æ®å—è§£ç æˆ`WatchEvent`å¯¹è±¡[^6]ï¼Œå¹¶å†™å…¥channelä¸­ï¼ˆä¹Ÿå°±æ˜¯å®ƒçš„`ResultChan`æˆå‘˜ï¼‰ã€‚
* æˆ‘ä»¬é€šè¿‡è¿­ä»£`ResultChan()`å°±å¯ä»¥"æºæºä¸æ–­"çš„ä»ä¸­è·å–èµ„æºçš„å˜æ›´äº‹ä»¶ã€‚

ä¸‹å›¾å±•ç¤ºä½¿ç”¨`RESTClient`ç›‘å¬èµ„æºæ—¶çš„è¿‡ç¨‹ï¼š

<WatchRequestSVG style={{width: "95%"}}/>

ä¸‹å›¾å±•ç¤ºäº†`StreamWatcher`å°†HTTPè¿”å›çš„æ•°æ®å—è½¬åŒ–ä¸ºäº‹ä»¶ç±»å‹å‘é€åˆ°channelçš„è¿‡ç¨‹ï¼š

<StreamWatcherSVG style={{height: "320px"}}/>

:::tip æ³¨
è‡³æ­¤ï¼Œæˆ‘ä»¬å·²ç»å­¦ä¼šä½¿ç”¨`RESTClient`ç›‘å¬èµ„æºçš„å˜æ›´ã€‚[ğŸˆ](../intro#çº¦å®š)
:::


é€šè¿‡ç›‘å¬èµ„æºçš„å˜æ›´äº‹ä»¶ï¼Œæˆ‘ä»¬å¯ä»¥å°†ä¸Šè¿°æ§åˆ¶å™¨åŸºç¡€ç‰ˆä¼ªä»£ç ä¼˜åŒ–ä¸ºï¼š
```go
for event := range eventChannel {
  desired := getDesiredState()
  current := getCurrentState()
  makeChanges(desired, current)
}
```
æˆ‘ä»¬å†ç¨ç¨è¡¥ä¸Šä¸€ç‚¹ç»†èŠ‚ï¼šæ ¹æ®æ§åˆ¶å™¨çš„å®šä¹‰ï¼Œ*æ§åˆ¶å™¨*æœ¬èº«è¦æœ‰æ£€ç´¢æŸç§ï¼ˆæˆ–è€…å¤šç§[^7]ï¼‰èµ„æºç±»å‹çš„æœŸæœ›çŠ¶æ€ä¸å®é™…çŠ¶æ€çš„èƒ½åŠ›ã€‚
ä¸€ç§ç®€å•ç›´æ¥çš„æ–¹å¼æ˜¯é€šè¿‡Kubernetes APIæ¥è·å–æ­¤åˆ»çš„èµ„æºçš„é›†åˆï¼š
```go
for event := range eventChannel {

  resources := getResourceListFromK8sAPI()

  for resource := range resources {
   makeChanges(resource.desired, resource.current)
  }

}
```
ç„¶è€Œè¿™å…¶å®å¹¶ä¸æ˜¯ä¸€ç§å¥½çš„åŠæ³•ã€‚
ä¸€æ–¹é¢ï¼Œé€šè¿‡Kubernetes APIæ£€ç´¢èµ„æºé›†åˆæœ¬èº«å¹¶ä¸é«˜æ•ˆ[^8]ã€‚å¦ä¸€æ–¹é¢ï¼Œåœ¨æ§åˆ¶å™¨ä¸­ï¼Œ*åè°ƒ*æ˜¯æ§åˆ¶å™¨ä¸­éœ€è¦é¢‘ç¹å‘ç”Ÿçš„åŠ¨ä½œã€‚

é‚£ä¹ˆåœ¨æ§åˆ¶å™¨ä¸­ï¼Œæˆ‘ä»¬è¯¥å¦‚ä½•é«˜æ•ˆåœ°è·å–èµ„æºé›†åˆå‘¢ï¼Ÿ
æˆ‘ä»¬ä¸å¦¨æ¢ä¸€ç§æ€è·¯ï¼ŒKubernetes APIçš„watchæœºåˆ¶ä¸ä»…ä»…å¯ä»¥è®©æˆ‘ä»¬æœ‰ç›‘å¬èµ„æºå˜æ›´çš„èƒ½åŠ›ï¼Œæˆ‘ä»¬ç†è®ºä¸Šæ˜¯ä¹Ÿå¯ä»¥**åˆ©ç”¨watchæœºåˆ¶æœ¬èº«åœ¨æœ¬åœ°ç»´æŠ¤ä¸€å¥—èµ„æºå½“å‰çš„æœ€æ–°å‰¯æœ¬**â€”â€”èµ„æºæœ€æ–°çš„çŠ¶æ€å…¶å®ç­‰åŒäºè¯¥èµ„æºæœ€æ–°çš„äº‹ä»¶ã€‚

### ä»watchæœºåˆ¶åˆ°Informer

å¹¸è¿çš„æ˜¯åœ¨`client-go`ä¸­ï¼Œå®˜æ–¹å¼€å‘è€…å·²ç»ä¸ºæˆ‘ä»¬å®ç°äº†**åŸºäºwatchæœºåˆ¶çš„æœ¬åœ°èµ„æºç¼“å­˜æœºåˆ¶**â€”â€”`Informer`ç»„ä»¶ã€‚å®ƒè®¾è®¡çš„åˆè¡·æ—¨åœ¨è®©å¼€å‘è€…å°½é‡é¿å…ç›´æ¥é€šè¿‡Kubernetes APIæ£€ç´¢èµ„æºé›†åˆä»è€Œè¾¾åˆ°å‡è½»KubernetesæœåŠ¡ç«¯å‹åŠ›ã€‚
å½“ç„¶ï¼Œå®ƒä¹Ÿå®Œç¾å¥‘åˆäº†æˆ‘ä»¬å¯¹äºæ§åˆ¶å™¨çš„éœ€æ±‚ï¼š
1. èµ„æºå˜æ›´äº‹ä»¶çš„é€šçŸ¥â€”â€”ä»¥ä¼˜åŒ–åè°ƒåŠ¨ä½œçš„è§¦å‘æ—¶æœºã€‚
2. Kubernetesèµ„æºçš„æœ¬åœ°ç¼“å­˜â€”â€”è®©æˆ‘ä»¬æ‹¥æœ‰ä¸€ä¸ªé«˜æ•ˆæ£€ç´¢Kubernetesèµ„æºé›†åˆçš„æ–¹å¼ã€‚


[^1]: *å£°æ˜å¼ç³»ç»Ÿ*å…¶å®æ˜¯ä¸€ä¸ªä¸*å‘½ä»¤å¼ï¼ˆimperativeï¼‰ç³»ç»Ÿ*ç›¸å¯¹çš„æ¦‚å¿µã€‚åœ¨å‘½ä»¤å¼ç³»ç»Ÿä¸­ï¼Œç”±ç”¨æˆ·æä¾›å¦‚ä½•ä½¿ç³»ç»Ÿè¾¾åˆ°æœŸæœ›çŠ¶æ€çš„å…·ä½“å‘½ä»¤åºåˆ—æˆ–æ­¥éª¤ã€‚
[^2]: è¿™ä¸ªå®šä¹‰å…¶å®æ˜¯æ•´åˆäº†å®˜æ–¹æ–‡æ¡£ä¸­ä¸¤ä¸ªå¯¹æ§åˆ¶å™¨çš„æè¿°ï¼š
      * [Controllers <KubernetesSVG />](https://kubernetes.io/docs/concepts/architecture/controller/)
        > In robotics and automation, a control loop is a non-terminating loop that regulates the state of a system.
        >
        > In Kubernetes, controllers are control loops that watch the state of your cluster, then make or request changes where needed.
        > Each controller tries to move the current cluster state closer to the desired state.

      * [Writing Controllers <GithubSVG />](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-api-machinery/controllers.md)
        > A Kubernetes controller is an active reconciliation process.
        > That is, it watches some object for the world's desired state, and it watches the world's actual state, too.
        > Then, it sends instructions to try and make the world's current state be more like the desired state.
[^3]: Kubernetesæ§åˆ¶å™¨å…¶å®å€Ÿç”¨äº†è‡ªåŠ¨åŒ–ä¸­*[closed-loop controller](https://en.wikipedia.org/wiki/Closed-loop_controller)*è¿™ä¸ªæ¦‚å¿µã€‚åœ¨è‡ªåŠ¨åŒ–é‡Œï¼Œclosed-loop controllerä½¿ç”¨åé¦ˆæ¥æ§åˆ¶åŠ¨æ€ç³»ç»Ÿçš„çŠ¶æ€æˆ–è¾“å‡ºã€‚å®ƒä»¬åœ¨æœ¬è´¨ä¸Šæ˜¯ç›¸é€šçš„ã€‚
[^4]: åœ¨Kubernetesç³»ç»Ÿä¸­ï¼ŒçœŸæ­£åˆ›å»ºpodèµ„æºçš„åŠ¨ä½œç”±kubeletç»„ä»¶å®Œæˆã€‚
[^5]: æ‰€è°“HTTP"æµ"æŒ‡çš„æ˜¯HTTP 1.1çš„*åˆ†å—ä¼ è¾“ç¼–ç *ï¼ˆ[HTTP/1.1 Chunked Transfer Coding](https://en.wikipedia.org/wiki/Chunked_transfer_encoding)ï¼‰ã€‚
      `kube-apiserver`ä¼šåœ¨è¿”å›çš„å¤´ï¼ˆheaderï¼‰ä¸­
      è®¾ç½®`Transfer-Encoding`ä¸º`chunked`ï¼Œè¡¨ç¤ºé‡‡ç”¨åˆ†å—ä¼ è¾“ç¼–ç ï¼Œå®¢æˆ·ç«¯æ¯è¯»å®Œä¸€ä¸ªæ•°æ®å—ï¼ˆå³èµ„æºçš„å˜æ›´äº‹ä»¶ï¼‰åï¼Œä¼šç»§ç»­è¯»å–æˆ–ç­‰å¾…ä¸‹ä¸€ä¸ªæ•°æ®å—ï¼Œç›´åˆ°å®¢æˆ·ç«¯ä¸»åŠ¨ç»ˆæ­¢è¿æ¥æˆ–è€…è¯»åˆ°é•¿åº¦ä¸º0çš„æ•°æ®åˆ†å—ä¸ºæ­¢ã€‚
      æ¯ä¸ªæ•°æ®å—ç”±ä¸¤éƒ¨åˆ†ç»„æˆï¼Œç¬¬ä¸€éƒ¨åˆ†æ˜¯ä»¥åå…­è¿›åˆ¶å½¢å¼è¡¨ç¤ºçš„åˆ†å—é•¿åº¦ï¼Œåé¢ç´§è·Ÿç€ `\r\n`ä»¥å‘ŠçŸ¥å®¢æˆ·ç«¯åˆ†å—çš„å¤§å°ã€‚ç¬¬äºŒéƒ¨åˆ†æ˜¯åˆ†å—æ•°æ®æœ¬èº«ï¼Œåé¢ä¹Ÿæ˜¯ `\r\n`ï¼Œ ç»ˆæ­¢å—åˆ™æ˜¯ä¸€ä¸ªé•¿åº¦ä¸º0çš„åˆ†å—ã€‚
[^6]: `WatchEvent`ç”±äºæ˜¯Kubernetes APIè¿”å›ä½“çš„è§£ç åçš„Goç±»å‹ï¼Œæ‰€ä»¥æ ¹æ®å®šä¹‰ï¼Œå®ƒä»ç„¶æ˜¯kindï¼Œå¹¶ä¸”å±äºkindçš„ç¬¬ä¸‰ç§ç±»ã€‚
[^7]: å¯¹äºå¤æ‚çš„æ§åˆ¶å™¨å¯èƒ½éœ€è¦åŒæ—¶ç®¡ç†`pods`, `services`ï¼Œ`configmaps`ç­‰å¤šç§èµ„æºç±»å‹ã€‚
[^8]: [Kubernetes API Concepts <KubernetesSVG />](https://kubernetes.io/docs/reference/using-api/api-concepts)
      > [Retrieving large results sets in chunks](https://kubernetes.io/docs/reference/using-api/api-concepts/#retrieving-large-results-sets-in-chunks)
      >
      > On large clusters, retrieving the collection of some resource types may result in very large responses that can impact the server and client.
      > For instance, a cluster may have tens of thousands of Pods, each of which is equivalent to roughly 2 KiB of encoded JSON. Retrieving all pods across all namespaces may result in a very large response (10-20MB) and consume a large amount of server resources.








